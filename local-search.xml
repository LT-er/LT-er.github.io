<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>配置博客自动改图片路径和自动剪切图片的尝试</title>
    <link href="/2024/03/09/try/"/>
    <url>/2024/03/09/try/</url>
    
    <content type="html"><![CDATA[<h3 id="解释一下这一句regex-r..">解释一下这一句regex =r'![.<em>?]((.</em>?))'</h3><p>这个正则表达式是用来匹配Markdown文档中图片链接格式的。</p><p>让我们逐步分解一下这个正则表达式：</p><ul><li><code>!</code>:在Markdown中，图片链接是以感叹号<code>!</code>开头的，所以正则表达式首先会查找感叹号。</li><li><code>[`: 紧跟着感叹号的是一个左方括号`[`，在正则表达式中方括号是一个特殊字符，用于定义字符集（character class）。因此，我们需要使用反斜杠</code>来转义它，以匹配文本中的实际方括号。<ul><li><code>.*?</code>:然后是点号<code>*</code>和问号<code>?</code>的组合。 -点号<code>.</code>代表任何单个字符（除了换行符）。 -星号<code>*</code>表示重复前面的字符零次或多次。 -问号<code>?</code>在这里是一个非贪婪（non-greedy）限定符，它告诉正则表达式引擎匹配尽可能少的字符，直到遇到下一个模式。</li><li><code>\]``: 这部分是查找与前面的左方括号相对应的右方括号</code>]`，同样地，由于方括号在正则表达式中有特殊含义，我们使用反斜杠``进行转义。</li></ul></li><li><code>\(</code>和<code>\)</code>:这两个是用来匹配实际的左右圆括号<code>(</code>和<code>)</code>，这两个圆括号用来括起Markdown中图片链接的URL路径，因为在正则表达式中圆括号具有特殊的分组功能，所以需要使用反斜杠<code>\</code>来转义它们。</li><li><code>(.*?)</code>: 这是一个捕获组（capturing group）：<ul><li>括号<code>()</code>定义了一个捕获组，用来捕获和存储匹配的数据以便将来引用。</li><li>点号<code>.*</code>同样表示匹配任何字符零次或多次。</li><li>问号<code>?</code>使得匹配变得非贪婪，即匹配尽量少的字符。</li></ul></li></ul><p>综上所述，正则表达式<code>r'!\[.*?\]\((.*?)\)'</code>整体查找的是一个标记了图片图像且不包含换行符的Markdown链接，它匹配以<code>![]</code>开始，紧跟一个括号内含任意字符（非贪婪匹配）的字符串。括号内的匹配部分（即图片的URL路径）被捕获以便之后使用。</p><h3id="我每次上传博客md文件和图像的话是需要g还是d">我每次上传博客md文件和图像的话是需要g还是d</h3><p>当你上传博客的Markdown文件和图像后，通常你需要先执行<code>hexo generate</code>（或其简写<code>hexo g</code>）来生成最新的静态文件，然后执行<code>hexo deploy</code>（或其简写<code>hexo d</code>）将这些静态文件部署到服务器上。</p><p>具体步骤通常是这样的：</p><ol type="1"><li>更新Markdown文件和图像到你的博客项目目录中。</li><li>在命令行中运行<code>hexo g</code>来生成网站的静态内容。这个过程会将你的Markdown和图像文件转换为网页文件，并将它们存放在<code>public</code>目录下。</li><li>完成网站的静态内容生成后，运行<code>hexo d</code>来部署这些内容到指定的服务器上，例如GitHubPages。</li></ol><p>如果你已经配置了Hexo的一键部署功能，在运行<code>hexo d</code>时，Hexo会自动将<code>public</code>目录中的内容推送到远程仓库，网站即会相应更新。</p><p>请记住，每次对博客内容做出更改，比如添加或编辑文章，或者更改图像等，你都需要运行这两个命令以确保你的更改被应用并展示在你的线上博客中。</p><h3id="error-cannot-spawn-.githookspre-commit-no-such-file-or-directory-everything-up-to-date-branch-master-set-up-to-track-gitgithub.comltspaceltspace.github.io.gitmaster.">error:cannot spawn .git/hooks/pre-commit: No such file or directory Everythingup-to-date branch 'master' set up to track'git@github.com:ltspace/ltspace.github.io.git/master'.</h3><p>这个错误信息表明Git在尝试执行<code>pre-commit</code>钩子时没有找到这个文件，这可能是由于以下几个原因造成的：</p><ol type="1"><li><code>pre-commit</code>钩子文件可能没有正确放置在<code>.git/hooks</code>目录中。</li><li><code>pre-commit</code>文件可能没有执行权限（在Windows环境下通常不需要设置执行权限，但有时可能受特定的环境配置影响）。</li><li>如果你使用Windows，并且手动创建了<code>pre-commit</code>文件，可能会不知不觉地给文件加上了默认的<code>.txt</code>等扩展名。</li></ol><p>针对以上情况，请检查以下几点：</p><ul><li>确认<code>pre-commit</code>文件位于正确的目录：<code>.git/hooks</code>。</li><li>确认文件名确实是<code>pre-commit</code>，没有隐藏的扩展名。在Windows文件资源管理器中查看文件名时，要确保设置允许显示已知文件类型的扩展名。</li><li>如果是通过文本编辑器创建的钩子脚本，确保在保存时选择“所有文件”类型，以避免自动添加扩展名。</li><li>尝试直接在命令行中执行<code>pre-commit</code>钩子脚本来看是否能正确运行。如果不能，可能是脚本本身存在问题，或者你的环境中没有安装Python或者脚本的执行路径不对（在脚本的开头<code>#!/bin/sh</code>可能需要指向正确的shell路径，这在Windows中通常不是必须的，但是依赖于你的环境配置）。</li></ul><p>如果上述都没问题，你可以尝试删除<code>pre-commit</code>钩子并重新创建它。如果错误仍然存在，那么需要对你的Git安装和配置环境做更深入的查看。在极端情况下，你可能需要重新安装Git或者调查是否有其它系统级的问题影响到了Git钩子的执行。</p><h3id="我的git仓库里.git的名字是.deploy_git是这个的原因吗">我的git仓库里.git的名字是.deploy_git，是这个的原因吗</h3><p>如果你的 <code>.git</code> 文件夹的名字被改为了<code>.deploy_git</code>，那很有可能是使用了Hexo的部署机制，特别是当采用<code>hexo-deployer-git</code>插件时，它会创建一个<code>.deploy_git</code>目录用来作为Git部署仓库。这个目录用于存储生成的静态文件，并将其推送到远程仓库，比如GitHubPages。</p><p><code>.deploy_git</code>目录与你本地编辑文档的Git仓库（通常用<code>.git</code>目录来管理）是分开的。Git钩子需要放在实际的Git仓库的<code>.git/hooks</code>目录中。如果你将钩子脚本放到了<code>.deploy_git</code>目录，那么它不会在你的常规Git操作中被触发。</p><p>解决方法如下：</p><ol type="1"><li>确认你的本地仓库（包含你编辑的源文件）的<code>.git</code>目录。它应该是你项目根目录的<code>.git</code>文件夹，而不是Hexo生成的<code>.deploy_git</code>文件夹。</li><li>将你的<code>pre-commit</code>钩子脚本放入你项目根目录下的<code>.git/hooks</code>目录中。</li><li>确保<code>pre-commit</code>钩子脚本具有正确的内容，并且能够在你尝试提交到你的源代码仓库时被触发。</li></ol><p>如果你尝试修改你的源代码并提交（例如使用<code>git commit</code>命令），那么钩子脚本应该在你项目的<code>.git/hooks</code>目录中被触发。如果你仅仅使用<code>hexo deploy</code>命令部署网站，它是不会触发这个钩子的，因为这通常会直接向<code>.deploy_git</code>仓库提交。</p><h3id="我发现我的.depoly_git里还有一个.git文件夹-这个文件夹又是干什么的">我发现我的.depoly_git里还有一个.git文件夹这个文件夹又是干什么的</h3><p>在Hexo项目中，<code>.deploy_git</code>文件夹是用于存储Hexo生成的静态文件以便部署到远程服务器的地方。当你使用<code>hexo-deployer-git</code>插件进行部署时，Hexo会将<code>public</code>目录中生成的静态文件复制到<code>.deploy_git</code>目录，并在该目录初始化一个新的Git仓库用于部署。</p><p><code>.deploy_git</code>目录中的<code>.git</code>文件夹是这个用于部署的Git仓库的元数据存储位置，其中包含了版本控制的相关信息，如分支、提交历史、配置等。实际上，<code>.deploy_git</code>目录本身就像是一个完整的Git仓库。</p><p>当你执行<code>hexo deploy</code>命令时，以下步骤会被触发：</p><ol type="1"><li>Hexo调用<code>hexo generate</code>生成静态文件。</li><li>生成的静态文件被复制到<code>.deploy_git</code>目录。</li><li>在<code>.deploy_git</code>目录执行Git命令，将变更添加(commit)到本地仓库，并将其推送(push)到远程服务器（如GitHubPages或其他托管服务）。</li></ol><p><code>.git</code>文件夹在<code>.deploy_git</code>目录中的作用是管理这一部署过程中所有的Git操作和历史记录。</p><p>如果你在尝试运行Git钩子时遇到问题，请确保钩子被放置于你的源代码仓库的<code>.git/hooks</code>目录中，而不是<code>.deploy_git</code>目录或其内的<code>.git</code>目录中。这样，当你操作源代码仓库时（比如执行<code>git commit</code>），钩子才会被正确触发。</p><figure><img src="/images/image-20240309112717007.png"alt="image-20240309112717007" /><figcaption aria-hidden="true">image-20240309112717007</figcaption></figure><h3id="我还需要额外再执行一遍git-commit的命令吗有没有方法让我只执行hexo-g--d">我还需要额外再执行一遍gitcommit的命令吗，有没有方法让我只执行hexo g -d</h3><p>如果要在执行 <code>hexo g -d</code> 的同时确保<code>pre-commit</code> 钩子被触发，你需要理解 <code>git commit</code>和 <code>hexo g -d</code> 在工作流程上的不同：</p><ul><li><code>git commit</code> 是Git版本控制系统的命令，当你执行它时会触发<code>.git/hooks</code> 中的钩子脚本。</li><li><code>hexo g -d</code>是Hexo的命令，用于生成静态网站内容并将其部署到配置的服务器上，不会直接触发Git的<code>pre-commit</code> 钩子。</li></ul><figure><img src="/images/image-20240309114430069.png"alt="image-20240309114430069" /><figcaption aria-hidden="true">image-20240309114430069</figcaption></figure><figure><img src="/images/image-20240309114453958.png"alt="image-20240309114453958" /><figcaption aria-hidden="true">image-20240309114453958</figcaption></figure><h3id="那我能不能把钩子放到.deploy_git的.git里这样就能hexo-g--d-的时候直接执行钩子了">那我能不能把钩子放到.deploy_git的.git里，这样就能hexog -d 的时候直接执行钩子了</h3><p>理论上，你可以将钩子脚本放在 <code>.deploy_git/.git/hooks</code>里面。因为这个 <code>.git</code>目录确实是一个git仓库，所以它应该能认可钩子脚本。但这样做有一些需要考虑的地方：</p><ol type="1"><li><strong>Hexo 工作流程</strong>：通常，<code>.deploy_git</code>仓库用于存放生成的静态文件，而不是源文件。如果你的钩子脚本主要是为了处理源文件（比如修改Markdown文件中的图片路径），那么它应该在源文件的git 仓库中被触发执行。</li><li><strong>自动化程度</strong>：把钩子放在 <code>.deploy_git</code>中确实可以在执行 <code>hexo deploy</code>时自动处理静态文件。但如果你的钩子脚本是为了更新本地的源Markdown文件的图片路径，那么这个静态文件是由源文件生成的，所以应该在更新源文件后、生成静态文件之前就处理好。</li><li><strong>维护性</strong>：<code>.deploy_git</code>目录通常不会提交到远程源码仓库，因为它的内容会在你运行<code>hexo clean</code>命令或者重新生成网站时被删除或覆盖。这意味着，如果你将钩子脚本放在<code>.deploy_git/.git/hooks</code> 中，当 <code>.deploy_git</code>目录被删除或重新生成时，你可能会丢失这个钩子脚本。</li></ol><p>总结来说，虽然理论上可以将钩子放在<code>.deploy_git/.git/hooks</code> 中使其在执行 <code>hexo g -d</code>时自动执行，但这样做并不是实践中常见的或推荐的工作流程。通常，我们会在源码仓库中处理这些任务，以确保源码的版本控制和钩子脚本可以一起正常工作。如果你确实需要自动化此过程，可能还是需要一个在源码阶段就能够触发的自定义的脚本或命令集。</p><h3id="以下是将图片移动和替换绝对路径为相对路径的功能合并到一个脚本中的代码">以下是将图片移动和替换绝对路径为相对路径的功能合并到一个脚本中的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> shutil<br><br># 设置目标目录<br>target_directory = <span class="hljs-string">&#x27;E:\\BLOG\\source\\images&#x27;</span><br><br># 配置你的Markdown文件的路径<br>markdown_directory = <span class="hljs-string">&#x27;E:\\BLOG\\source\\_posts&#x27;</span><br># 配置存放图片的文件夹名称，相对于markdown_directory<br>images_directory = <span class="hljs-string">&#x27;images&#x27;</span><br><br><br># 替换绝对路径为相对路径的函数<br>def <span class="hljs-built_in">replace_image_path</span>(file_path, image_dir):<br>    # 建立一个正则表达式模式匹配Markdown图片链接<br>    regex = r<span class="hljs-number">&#x27;</span>!\[.*?\]\((.*?)\)&#x27;<br><br>    # 读取Markdown文件内容<br>    with <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) as file:<br>        content = file.<span class="hljs-built_in">read</span>()<br><br>    # 使用正则表达式匹配并替换路径<br>    new_content = content<br>    matches = re.<span class="hljs-built_in">findall</span>(regex, content)<br>    <span class="hljs-keyword">for</span> match in matches:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> match.<span class="hljs-built_in">startswith</span>(<span class="hljs-string">&#x27;http&#x27;</span>):  # 只替换本地文件路径<br>            new_image_path = os.path.<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;/&#x27;</span>, image_dir, os.path.<span class="hljs-built_in">basename</span>(match)).<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>)<br>            new_content = new_content.<span class="hljs-built_in">replace</span>(match, new_image_path)<br><br>    # 写回新的内容到文件<br>    with <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) as file:<br>        file.<span class="hljs-built_in">write</span>(new_content)<br><br><br># 写一个函数来处理文件的移动，并替换Markdown文件中图片的引用<br>def <span class="hljs-built_in">process_markdown_files</span>(md_directory, target_dir):<br>    <span class="hljs-keyword">for</span> root, dirs, files in os.<span class="hljs-built_in">walk</span>(md_directory):<br>        <span class="hljs-keyword">for</span> file in files:<br>            <span class="hljs-keyword">if</span> file.<span class="hljs-built_in">lower</span>().<span class="hljs-built_in">endswith</span>(<span class="hljs-string">&#x27;.md&#x27;</span>):<br>                full_path = os.path.<span class="hljs-built_in">join</span>(root, file)<br>                <span class="hljs-built_in">move_images</span>(full_path, target_dir)<br>                <span class="hljs-built_in">replace_image_path</span>(full_path, images_directory)<br><br><br># 处理文件移动的函数<br>def <span class="hljs-built_in">move_images</span>(md_file_path, target_dir):<br>    with <span class="hljs-built_in">open</span>(md_file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) as file:<br>        content = file.<span class="hljs-built_in">read</span>()<br><br>    # 正则表达式查找所有 Markdown 图片链接<br>    image_paths = re.<span class="hljs-built_in">findall</span>(r<span class="hljs-number">&#x27;</span>!\[.*?\]\((.*?)\)<span class="hljs-string">&#x27;, content)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    if not image_paths:</span><br><span class="hljs-string">        print(f&quot;No images found in &#123;md_file_path&#125;&quot;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    for image_path in image_paths:</span><br><span class="hljs-string">        # 检查是否是绝对路径</span><br><span class="hljs-string">        if os.path.isabs(image_path):</span><br><span class="hljs-string">            # 获取图片名和目标路径</span><br><span class="hljs-string">            image_name = os.path.basename(image_path)</span><br><span class="hljs-string">            destination = os.path.join(target_dir, image_name)</span><br><span class="hljs-string"></span><br><span class="hljs-string">            # 显示正在处理的图片</span><br><span class="hljs-string">            print(f&quot;Processing image: &#123;image_name&#125;&quot;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">            # 如果目标路径下没有这个文件再进行移动</span><br><span class="hljs-string">            if not os.path.exists(destination):</span><br><span class="hljs-string">                # 尝试移动图片，如果原始图片路径不存在则会抛出异常</span><br><span class="hljs-string">                try:</span><br><span class="hljs-string">                    shutil.move(image_path, destination)</span><br><span class="hljs-string">                    print(f&#x27;</span>Moved image &#123;image_name&#125; to &#123;target_dir&#125;<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">                except FileNotFoundError:</span><br><span class="hljs-string">                    print(f&#x27;</span>Image <span class="hljs-keyword">not</span> found at &#123;image_path&#125;, skipped moving<span class="hljs-number">&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(f<span class="hljs-number">&#x27;</span>Image &#123;image_name&#125; already exists in target directory; no action taken<span class="hljs-number">&#x27;</span>)<br><br><br># 开始处理Markdown文件和图片<br><span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;Processing Markdown files and images in &#123;markdown_directory&#125;&quot;</span>)<br><span class="hljs-built_in">process_markdown_files</span>(markdown_directory, target_directory)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;All Markdown file image paths and images have been processed.&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DAY3日寄-苍穹外卖02-力扣刷题</title>
    <link href="/2024/03/09/DAY3/"/>
    <url>/2024/03/09/DAY3/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr /><h3id="当你想要重新学习并使用-c-来刷力扣leetcode时以下是一些建议和步骤可以帮助你">当你想要重新学习并使用C++ 来刷力扣（LeetCode）时，以下是一些建议和步骤可以帮助你：</h3><p>复习基础知识：</p><ul><li><strong>复习语法</strong>：回顾 C++的基本语法，如变量、数据类型、运算符、流程控制等。</li><li><strong>STL（标准模板库）</strong>：学习 C++标准库中的常用数据结构和算法，如向量（vector）、映射（map）、队列（queue）、堆栈（stack）等。</li></ul><p>相等的时候先放nums1的元素</p><h3 id="vector自动变化大小">vector自动变化大小</h3><ol type="1"><li><strong>获取数组大小</strong>：使用 <code>size()</code>成员函数来获取数组的大小（元素个数）。例如，要获取数组的大小，可以使用<code>nums1.size()</code>。</li><li><strong>插入元素</strong>：使用 <code>push_back()</code>成员函数将元素添加到数组的末尾。例如，要将新元素 <code>5</code>插入到数组末尾，可以使用 <code>nums1.push_back(5)</code>。</li><li><strong>删除元素</strong>：使用 <code>pop_back()</code>成员函数删除数组的最后一个元素。例如，要删除数组的最后一个元素，可以使用<code>nums1.pop_back()</code>。</li><li><strong>遍历数组</strong>：使用循环结构（如 <code>for</code>循环）和索引操作符 <code>[]</code>来遍历数组中的所有元素。例如，可以使用以下代码遍历并打印数组中的所有元素：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    cout &lt;&lt; nums1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sort</code>函数接受两个迭代器作为参数，表示排序范围的起始和结束位置。如果要进行降序排序，可以使用<code>sort(myVector.rbegin(), myVector.rend())</code>，其中<code>rbegin()</code>和<code>rend()</code>表示逆序的起始和结束位置。</p><p>sort(myVector.begin(), myVector.end()); <em>// 默认升序排序</em></p><h3 id="合并两个有序数组">合并两个有序数组</h3><p>先将数组 nums2放进数组 nums1的尾部，然后直接对整个数组进行排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            nums1[m+i]=nums2[i];<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(),nums1.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 C++ 中，你不能直接通过 <code>int i = j = p = 0;</code>这样的方式来同时初始化多个变量，因为 C++ 不支持链式赋值。</p><p>还是一天做一道题吧...</p><h3 id="ctrl鼠标左键跳入类">ctrl+鼠标左键跳入类</h3><h3 id="selectselect-from-employee-where-username-username"><spanclass="citation" data-cites="Select">@Select</span>("select * fromemployee where username = #{username}")</h3><p>看起来你提供的代码片段类似于MyBatis中的SQL查询语句。这段代码使用了MyBatis的注解<code>@Select</code>，并包含了一个查询语句<code>select * from employee where username = #&#123;username&#125;</code>。</p><p>在这个查询语句中，<code>#&#123;username&#125;</code>是一个参数占位符，表示在实际执行查询时会替换为具体的<code>username</code>的值。这种方式可以有效防止SQL注入攻击。</p><p>需要注意的是，<code>@Select</code>注解通常用于在MyBatis的Mapper接口方法上，用于指定对应的SQL查询语句。在实际使用中，你需要确保传入正确的参数值来执行这个查询。</p><h3id="mybatis会自动处理参数的转义和过滤以防止sql注入攻击">MyBatis会自动处理参数的转义和过滤，以防止SQL注入攻击。</h3><p>它使用预编译语句（PreparedStatement）或命名参数来处理参数，并在执行查询之前自动进行参数值的转义。</p><p>当你在MyBatis的注解语句中使用<code>#&#123;&#125;</code>占位符时，MyBatis会自动将参数进行安全处理。它会确保参数值不会被误解为SQL代码的一部分，并且会对特殊字符进行转义，从而防止注入攻击。</p><p>因此，当使用MyBatis进行数据库查询时，你无需手动编写过滤或转义逻辑来防止SQL注入攻击。但是，仍然需要保证输入的参数值都是可信的，以避免其他类型的安全漏洞。</p><p>在Windows环境下，文件默认是可执行的，所以你不需要像在Unix-like系统中那样修改文件权限。只需确保你的<code>pre-commit</code>钩子脚本的内容是正确的，并且它放置在<code>.git/hooks</code>目录下。</p><h3 id="hexo-clean之后我所有放在source里的图片是不是都会被删除">hexoclean之后，我所有放在source里的图片是不是都会被删除</h3><p>使用<code>hexo clean</code>命令的作用主要是清除Hexo生成的缓存（<code>.db</code>文件）和已生成的静态文件（通常是<code>public</code>目录下的内容）。这个命令不会删除<code>source</code>目录下的内容，包括您放置在那里的图片。</p><p>在Hexo项目结构中，<code>source</code>目录是用来存放所有资源文件的地方，包括Markdown文件、图片以及其它静态文件等。在运行<code>hexo generate</code>或<code>hexo server</code>命令时，Hexo会从<code>source</code>目录读取文件，并生成相应的静态网页放到<code>public</code>目录。</p><p>因此，您可以放心使用<code>hexo clean</code>，它不会影响到您在<code>source</code>中储存的资源文件。不过，无论何时进行文件操作，定期备份仍然是一个好习惯，以防万一出现意外情况。</p>]]></content>
    
    
    <categories>
      
      <category>日寄</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DAY2日寄-苍穹外卖01-毕设电子-java八股</title>
    <link href="/2024/03/08/DAY2/"/>
    <url>/2024/03/08/DAY2/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><figure><img src="/images/image-20240308094713778.png"alt="image-20240308094713778" /><figcaption aria-hidden="true">image-20240308094713778</figcaption></figure><figure><img src="/images/image-20240308094749852.png"alt="image-20240308094749852" /><figcaption aria-hidden="true">image-20240308094749852</figcaption></figure><figure><img src="/images/image-20240308095429320.png"alt="image-20240308095429320" /><figcaption aria-hidden="true">image-20240308095429320</figcaption></figure><figure><img src="/images/image-20240308100445990.png"alt="image-20240308100445990" /><figcaption aria-hidden="true">image-20240308100445990</figcaption></figure><figure><img src="/images/image-20240308102810152.png"alt="image-20240308102810152" /><figcaption aria-hidden="true">image-20240308102810152</figcaption></figure><figure><img src="/images/image-20240308103740063.png"alt="image-20240308103740063" /><figcaption aria-hidden="true">image-20240308103740063</figcaption></figure><p>在acwing花了两千块钱了</p><figure><img src="/images/image-20240308104638739.png"alt="image-20240308104638739" /><figcaption aria-hidden="true">image-20240308104638739</figcaption></figure><p>双击nginx项目的nginx.exe就能启动，路径不能带中文，localhost，端口默认80不用输入</p><h3id="万用表交流测的是峰峰所以电压会达到六百多伏">万用表交流测的是峰峰，所以电压会达到六百多伏</h3><p><ahref="https://www.bilibili.com/video/BV1Mc411o7gN?p=3&amp;vd_source=e404ad14246992bcc3e4ac52a33df8ed">（基础）基本电路知识_哔哩哔哩_bilibili</a></p><p>DTO data transfer object 数据传输对象，各层传输数据</p><p>VO view object 视图对象，前端展示</p><p>POJO 只有属性和getter和setter</p><p>Entity 实体，对应数据库表</p><h3 id="idea等连接github的代理设置">idea等连接github的代理设置</h3><p>对windows用户来说，只需要在命令行执行如下命令即可。这样就可以通过代理访问github了。</p><p>如果是http代理：</p><p>git config --global http.https://github.com.proxyhttp://127.0.0.1:7890</p><p>//如果是sock代理 git config --global http.https://github.com.proxysocks5://127.0.0.1:1080</p><figure><img src="/images/image-20240308161233439.png"alt="image-20240308161233439" /><figcaption aria-hidden="true">image-20240308161233439</figcaption></figure><p><ahref="https://blog.csdn.net/weixin_45959563/article/details/120295759">idea报错解决办法：Errorexecuting Maven. The specified user settings file does not exist:C:.m2-CSDN博客</a></p><figure><img src="/images/image-20240308161746203.png"alt="image-20240308161746203" /><figcaption aria-hidden="true">image-20240308161746203</figcaption></figure><figure><img src="/images/image-20240308162617063.png"alt="image-20240308162615780" /><figcaption aria-hidden="true">image-20240308162615780</figcaption></figure><p>application.yml里改了端口号，8080和8090都在被占用，但netstat发现没被占用，最后改成42220就行了奇怪</p><p>mysql命令</p><figure><img src="/images/image-20240308163604573.png"alt="image-20240308163604573" /><figcaption aria-hidden="true">image-20240308163604573</figcaption></figure><p>ERROR 1045 (28000): Access denied for user 'root'@'localhost' (usingpassword: YES)</p><figure><img src="/images/image-20240308164001405.png"alt="image-20240308164001405" /><figcaption aria-hidden="true">image-20240308164001405</figcaption></figure><p>要用管理员shell运行mysql的启动停止命令，mysql的名称是mysql80，不分大小写</p><h3 id="mysql服务的启动和停止">mysql服务的启动和停止</h3><p>net start mysql80</p><p>记得有80（在win+r的service.msc里看的服务名）</p><p><ahref="https://blog.csdn.net/weixin_40873693/article/details/113056113">执行scquery mysql，sc delete mysql没有反应_sc deletemysql80没有反应-CSDN博客</a></p><p><ahref="https://blog.csdn.net/qq_42785280/article/details/97255637">MySQL：netstart MySQL80：发生系统错误 5。拒绝访问。_net start mysql80 发生系统错误5。 拒绝访问。-CSDN博客</a></p><p><ahref="https://blog.csdn.net/hkdhkdhkd/article/details/121158926">Mysql忘记登录密码的解决步骤（完整步骤）_mysql密码忘了怎么办-CSDN博客</a></p><p><ahref="https://blog.csdn.net/weixin_40845165/article/details/100943054">ERROR1054 (42S22): Unknown column 'password' in 'field list'-CSDN博客</a></p><figure><img src="/images/image-20240303092609821.png"alt="image-20240303092609821" /><figcaption aria-hidden="true">image-20240303092609821</figcaption></figure><figure><img src="/images/image-20240303092857419.png"alt="image-20240303092857419" /><figcaption aria-hidden="true">image-20240303092857419</figcaption></figure><p>重装了一遍mysql，密码改成了0000</p><h3id="我在idea里改了几个参数再重新运行项目的时候还需要重新maven构建吗">我在idea里改了几个参数，再重新运行项目的时候还需要重新maven构建吗</h3><p>一般来说，如果你在IDEA中改变了项目中的参数，并且这些参数是在构建过程中被使用到的（例如pom.xml中的配置参数），那么重新进行Maven构建可能是必要的，以确保这些变化被正确应用。如果是改变了代码中的参数，而这些参数不影响项目的依赖关系或构建过程，通常仅需要重新编译改动的部分即可。不过进行完整构建可以确保一切都是最新的，避免某些情况下因为环境的不同步导致的问题。</p><h3 id="启动流程">启动流程：</h3><p>1前端nginx文件夹双击</p><p>2 mysql启动（mysql -u root -p）</p><p>3 idea，skyserver，skyapplication类启动</p><p>注意点：</p><p>application-dev.yml改mysql的密码的时候，纯数字要加单引号</p><h3id="nginx配置文件里的这一段中weight是干什么用的">nginx配置文件里的这一段中，weight是干什么用的</h3><p>upstream webservers{ server 127.0.0.1:8080 weight=90 ; #server127.0.0.1:8088 weight=10 ; }</p><p>在Nginx配置文件的<code>upstream</code>模块中，<code>weight</code>参数用于定义负载均衡时各服务器的权重比例。在你这个<code>upstream</code>块中，使用了<code>weight</code>参数来分配请求到不同服务器的相对比例。</p><ul><li><code>server 127.0.0.1:8080 weight=90;</code>表明第一个服务器（在这里是本机的8080端口上的服务器）的权重是90。</li><li><code>#server 127.0.0.1:8088 weight=10;</code>这一行已被注释掉，但如果取消注释，它将表明第二个服务器（在这里是本机的8088端口上的服务器）的权重是10。</li></ul><p>当有一个请求到达<code>upstream</code>定义的服务器组时，Nginx会按照权重来决定将请求发送到哪个服务器。在这个例子中，如果第二行没有被注释掉，那么理论上每有100个请求，大约90个会被发送到端口8080上的服务器，而大约10个请求会被发送到端口8088的服务器。</p><p>使用权重可以使得流量分配更加灵活，特别是当服务器的处理能力不相同时，可以通过调整权重来分配更多的请求到性能更强的服务器上。</p><h3 id="断点调试">断点调试</h3><figure><img src="/images/image-20240308183647122.png"alt="image-20240308183647122" /><figcaption aria-hidden="true">image-20240308183647122</figcaption></figure><p>ctrl+alt+B，跳转到方法.</p><figure><img src="/images/image-20240308184049708.png"alt="image-20240308184049708" /><figcaption aria-hidden="true">image-20240308184049708</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>日寄</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DAY1日寄-主修毕设电路原理图绘制</title>
    <link href="/2024/03/08/DAY1/"/>
    <url>/2024/03/08/DAY1/</url>
    
    <content type="html"><![CDATA[<h2 id="day1日寄-主修毕设电路原理图绘制">DAY1日寄主修毕设电路原理图绘制</h2><p>常见暖气片漏水部位：</p><p>由于工艺的原因，暖气片片头与柱体是焊接在一起的，并不是一个整体，焊点处最容易被腐蚀。</p><p>毕设要做基于esp8266的暖气片漏水检测系统，要自己画电路板，温湿度检测，要知道暖气片口径的尺寸 内径为20mm，外径约为25mm</p><p>流量传感器的数据需要有自学习的过程，一段时间后应该有最优的数值，esp8266传到手机端的报警信号，手机端可发送控制命令关闭暖气的阀门，理论上不是很难，但细节要详细设计，包括pcb板都要设计好。</p><p>stm32最小系统板？√</p><p>esp8266√</p><p>oled屏幕√</p><p>mos管控制电磁阀√</p><p>有源蜂鸣器√</p><p>流量传感器（已经下单）</p><p>AC交流，DC直流</p><p>S8050三极管驱动继电器，继电器控制电磁阀</p><p>0欧姆电阻？</p><figure><img src="/images/image-20240307112316088.png"alt="image-20240307112316088" /><figcaption aria-hidden="true">image-20240307112316088</figcaption></figure><figure><img src="/images/image-20240307180836061.png"alt="image-20240307180836061" /><figcaption aria-hidden="true">image-20240307180836061</figcaption></figure><p>我现在在画基于stm32的pcb板，我先从网上下载了stm32最小系统板的原理图，再自己添加上esp8266等模块，但是我有个问题，就是我下载的stm32最小系统板的原理图里，stm32的可用引脚都通过排针外扩了，我如果把已经外扩了的引脚也连到我添加的esp8266模块上会发生什么，这么做是对的吗，我能在外扩的同时也连接模块吗</p><p>没问题的，其实这样的设计在PCB板设计中很常见。STM32的可用引脚通过排针外扩，是为了能够便捷地连接到其他电路或测试设备。至于你想要将这些引脚同时连到ESP8266模块上，完全是可以的，前提是你需要确保以下几点：</p><ol type="1"><li>电气连接正确：确保STM32的引脚与ESP8266模块的对应引脚电气特性兼容，没有冲突。比如说，不要把供电引脚错误地连接到地引脚或信号引脚。</li><li>信号干扰问题：当一个引脚连接多个模块时，可能会引入信号干扰。你需要设计合适的走线和地平面,并在必要时添加适当的滤波和隔离元件。</li><li>I/O负载：确保STM32的I/O引脚没有超出其承受的驱动能力。每个I/O引脚都能提供一定的电流，你要检查所有连接到该引脚的模块总共需要的电流是否超出了STM32引脚的最大输出电流。</li><li>软件管理：在软件层面，你需要正确地配置STM32的I/O引脚，避免在程序中造成引脚状态的冲突。</li></ol><p>只要你能够处理好上述提到的几个方面，你就可以在外扩的同时也连接模块。当然，进行这样的设计之前，最好还是好好规划一下，确保整个系统的稳定性和可靠性。开工前做好设计和规划，事半功倍喔</p><p>当你将STM32的一个单独引脚同时连接到外扩引脚和另一个模块（比如ESP8266）时，在软件编程方面需要考虑到以下几点：</p><ol type="1"><li><strong>引脚功能冲突</strong>：确保在同一时刻，这个引脚不会被外扩接口和ESP8266同时要求执行不同的功能。你需要设计你的程序逻辑来避免这种冲突，比如通过状态机来管理这个引脚的状态。</li><li><strong>引脚方向设置</strong>：程序中需要设置GPIO的输入/输出方向。如果引脚被配置为输出，STM32将能够向ESP8266发送信号；如果配置为输入，STM32将能够接受来自ESP8266的信号。如果同一时刻既想读信号也想写信号，就需要编写控制代码来临时切换引脚状态。</li><li><strong>互斥访问</strong>：如果某一时刻只允许外扩引脚或者ESP8266中的一个与STM32的引脚进行通信，你需要确保程序中通过某种互斥机制来管理这种通信的访问。可以通过软件标志位来确定哪个模块可以使用该引脚。</li></ol><p>举个例子:假设有一个引脚PA0，你同时连接到了外扩接口和ESP8266。那么你的程序可能会这样控制：</p><p>c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 检测ESP8266模块是否需要通信</span><br><span class="hljs-keyword">if</span> (ESP8266_needs_communication) &#123;<br>    <span class="hljs-comment">// 配置PA0为通信所需的模式</span><br>    GPIO_InitStruct.Pin = GPIO_PIN_0;<br>    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; <span class="hljs-comment">// 假设为特定的替代功能</span><br>    GPIO_InitStruct.Pull = GPIO_NOPULL;<br>    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);<br>    <br>    <span class="hljs-comment">// 与ESP8266模块进行数据交换</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 如果外扩接口需要使用PA0</span><br><span class="hljs-keyword">if</span> (extension_needs_communication) &#123;<br>    <span class="hljs-comment">// 配置PA0为外扩接口所需的模式</span><br>    GPIO_InitStruct.Pin = GPIO_PIN_0;<br>    GPIO_InitStruct.Mode = GPIO_MODE_INPUT; <span class="hljs-comment">// 假设外扩为输入模式</span><br>    GPIO_InitStruct.Pull = GPIO_PULLUP;<br>    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);<br><br>    <span class="hljs-comment">// 与外扩接口进行数据交换</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在实际应用中，你可能还需要加入一些延时或者中断，以确保STM32可以正确地处理来自不同源的信号。还有很多优雅的处理方式，上面的代码只是一个简单的示例。</p><p>记住，当你设计这样的复用引脚时，一定要确保不会引起电气层面的冲突，并且确保在任何时刻引脚状态的改变都是在你的控制之下，不会不经意间发生。</p><figure><img src="/images/image-20240307185323901.png"alt="image-20240307185323901" /><figcaption aria-hidden="true">image-20240307185323901</figcaption></figure><figure><img src="/images/image-20240307185338961.png"alt="image-20240307185338961" /><figcaption aria-hidden="true">image-20240307185338961</figcaption></figure><p>当然可以，ESP8266-12F是一个非常受欢迎的WiFi模块，具有紧凑的尺寸和低功耗，非常适合物联网(IoT)项目。以下是常见的几个原理图连接点的解释：</p><ol type="1"><li><strong>天线</strong>:ESP8266-12F包含一个PCB板天线，且通常不需要外加天线。这是连接到无线网络的关键部分。</li><li><strong>电源</strong>：ESP8266-12F需要一个稳定的3.3V电源，供电电压不能高于3.6V。可能还会看到一个电源旁有去耦电容以稳定电源，并避免因为供电波动造成运行时的不稳定。</li><li><strong>GPIO</strong>：这些引脚为通用输入输出端口，用来连接传感器、执行器或其他模块。</li><li><strong>串行通信引脚（RX/TX）</strong>：这些用于与ESP8266交流数据，如用于编程固件或和其他设备的通信。</li><li><strong>CH_PD(ChipEnable)</strong>引脚需要连接到VCC来激活芯片；</li><li><strong>RESET</strong>：复位引脚可用于重启模块。</li><li><strong>GPIO15, GPIO0,GPIO2</strong>和<strong>EN（Enable）</strong>引脚通常会有特定的上拉或下拉电阻，以确保ESP8266在启动时能进入正确的启动模式。比如：<ul><li><strong>GPIO15</strong>需要接地（带下拉电阻）。</li><li><strong>GPIO0</strong>决定了模块是进入编程模式还是正常启动，通常通过上拉来正常启动。</li><li><strong>GPIO2</strong>也需要上拉。</li></ul></li><li><strong>去耦电容</strong>：在电源线和地之间接去耦电容非常重要，这有助于滤除电源中的噪声，使模块运行更加稳定。</li></ol><p>每个电路设计都有其特定目的和电气特性的考量。设计者在手册或数据表的指导下进行设计，以确保模块稳定工作并遵守电气规范。如果你有特定的设计方面的问题或者需要详细的电路解释，提供更多的上下文将有助于给出更精确的解答。希望这些信息对你的项目有帮助！🛠️📡</p><h3id="要将-esp8266-12f-wifi-模块与-stm32f103c8t6-微控制器连接并控制它你可以按照以下简单步骤操作">要将ESP8266-12F WiFi 模块与 STM32F103C8T6微控制器连接并控制它，你可以按照以下简单步骤操作：</h3><ol type="1"><li><strong>供电</strong>：<ul><li>ESP8266 需要 3.3V 的电源，这意味着你可以直接从 STM32 板上的 3.3V引脚供电给 ESP8266。</li><li>确保你的电源能够提供足够的电流，因为 ESP8266在启动或通信时可能会短暂消耗较高功率。</li></ul></li><li><strong>串行通信</strong>：<ul><li>将 ESP8266 的 TX（发送）引脚连接到 STM32F103C8T6 的某个 UART接收（RX）引脚上。</li><li>将 ESP8266 的 RX（接收）引脚连接到 STM32F103C8T6 的某个 UART发送（TX）引脚上。</li><li>选择合适的 GPIO 引脚分配给 UART 接口，并在 STM32软件中适当配置。</li></ul></li><li><strong>编程与控制</strong>：<ul><li>使用 STM32 的 UART 接口，通过发送 AT 指令来控制ESP8266。这些指令用于设置网络连接、发送数据等。</li><li>根据你的需要，可能要编写或使用一个串口库来管理 UART 通讯。</li></ul></li><li><strong>GPIO 互连</strong>（可选）：<ul><li>如果你需要更精细的控制，如重置 ESP8266 或监控其状态，你也可以将ESP8266 的 GPIO 引脚（如 CH_PD 或 RESET）连接到 STM32 的 GPIO引脚，并通过软件控制它们。</li></ul></li><li><strong>软件配置</strong>：<ul><li>在 STM32 中设置 UART 接口的波特率，确保它与 ESP8266的设置相匹配。</li><li>实现或使用一个库来发送 AT 指令并解析响应。</li><li>创建一个循环来维护 WiFi 连接，处理网络通信任务。</li></ul></li></ol><p>下面是一个示例连接图：</p><table><thead><tr class="header"><th>ESP8266</th><th>STM32F103C8T6</th></tr></thead><tbody><tr class="odd"><td>VCC</td><td>3.3V</td></tr><tr class="even"><td>GND</td><td>GND</td></tr><tr class="odd"><td>TX</td><td>PA10 (RX)</td></tr><tr class="even"><td>RX</td><td>PA9 (TX)</td></tr><tr class="odd"><td>CH_PD</td><td>3.3V (通常与 VCC 连接)</td></tr><tr class="even"><td>RESET</td><td>(可选连接至 STM32 GPIO)</td></tr></tbody></table><p>在编写代码来控制 ESP8266 之前，请确保你已经通过 USB-to-Serial转换器或类似的东西更新了 ESP8266 的固件，并且能够理解和使用 AT指令集。</p><p>请牢记：</p><ul><li>在连接之前，请双检查所有的引脚配置，以避免任何硬件损坏。</li><li>焊接 ESP8266-12F 模块通常比较困难，因为它是一个带有金属盖的小型 SMD模块。小心操作，以免烧坏模块或相关的电路。</li></ul><h3id="要通过i2c接口连接stm32f103c8t6以下简称stm32与hs96l03-oled显示模块以下简称oled您需要按照以下步骤操作">要通过I2C接口连接STM32F103C8T6（以下简称STM32）与HS96L03OLED显示模块（以下简称OLED），您需要按照以下步骤操作：</h3><ol type="1"><li><strong>电源连接</strong>：<ul><li>将STM32的VCC引脚连接到OLED模块的VCC，提供所需电压（通常为3.3V或5V，需根据规格书确定）。</li><li>将STM32的GND引脚连接到OLED模块的GND，形成共同的地线。</li></ul></li><li><strong>I2C数据线连接</strong>：<ul><li>将STM32的I2C_SDA引脚连接到OLED模块的SDA引脚。</li><li>将STM32的I2C_SCL引脚连接到OLED模块的SCL引脚。</li></ul></li><li><strong>外接上拉电阻</strong>：<ul><li>在SDA和SCL线路上，分别外接上拉电阻到VCC。通常电阻值可以选择在4.7kΩ到10kΩ之间，具体值需要根据系统的I2C总线长度以及所用OLED模块的电气特性来决定。</li></ul></li><li><strong>配置STM32</strong>：<ul><li>在STM32的固件中配置I2C接口，包括初始化I2C时钟速率、地址模式和所使用的I2C端口等。</li><li>如果OLED模块有特定的初始化序列，也需要按照规格书中的要求，在STM32固件中加入相应的初始化代码。</li></ul></li><li><strong>编写显示代码</strong>：<ul><li>开发相应的软件来驱动OLED，并实现所需的显示功能，比如显示文本、图像等。</li></ul></li><li><strong>实际测试</strong>：<ul><li>在接线完成后，上传固件并对连接进行测试，以确保I2C通信正常工作且OLED可以正确显示。</li></ul></li></ol><p>在进行连接前，请确保参考STM32以及OLED的规格书来获取精确的接线信息及电气参数，防止因误接线而损坏设备。此外，在连接OLED之前，请先通过STM32的数据手册验证其的I2C引脚位置，因为不同的STM32模型其I2C引脚配置可能会有所不同。如果一切按照上述步骤进行并且规格都符合要求，那么I2C接口的连接应该就能够实现功能。</p>]]></content>
    
    
    <categories>
      
      <category>日寄</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24考研的具体经验反思</title>
    <link href="/2024/03/02/24%E8%80%83%E7%A0%94%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%8F%E9%AA%8C%E5%8F%8D%E6%80%9D/"/>
    <url>/2024/03/02/24%E8%80%83%E7%A0%94%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%8F%E9%AA%8C%E5%8F%8D%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="考研的具体经验反思">24考研的具体经验反思</h1><p>（未完成）</p><hr /><p>我觉得github上有个仓库极其的好，叫《考研：有手就行》</p><p>这位大哥是二战的，22年分数一般，但23年上岸上交计算机，水平真不是一般人，</p><blockquote><ul><li>第一次的初试分数是79 + 72 + 93 + 86 = 330（11408），未进复试。</li><li>第二次的初试分数是80 + 75 + 137 + 122 =414（11408），复试分数是180分（总分200）。</li></ul></blockquote><p>我今年是64 + 79 + 97 + 100 = 340（11408），</p><p>鉴于我这北京和他那上海都挺旱的，只能说我俩一战水平差不多。</p><hr /><p>他给出了无比具体且可量化的方法，</p><p>趁现在还早，你如果严格按照他的方式来，是真的可以考个巨无敌高的分数。</p><p>（额也说不定，万一明年题更难了，超纲题更多了，这种情况看谁都没用）</p><p>我当时看到的时候已经晚了。</p><hr /><p>记得这个库还是后台一粉丝介绍给我的，说我和那个大佬理念很相似，</p><p>经过这一切之后再想起这个评价，真是太讽刺了。</p><hr /><p>我其实不想由果索因，因为会额外否定很多东西。</p><p>但没有结果的时候，又会不自觉美化自己的行为。</p><hr /><p>个人情况：</p><p>山东高考，末流985，计算机本科，一战北京11408，笨拙的努力型选手。</p><hr /><h2 id="政治">1 政治</h2><p>客观39，主观25，总分64.</p><p>简单来说，还是别花时间学政治了。</p><hr /><h3 id="选择">1.1 选择</h3><p>我后期买了那个喵刷政治的微信小程序，也买了苍盾政治的小程序，</p><p>比较之后用喵刷，UI简洁舒适，能归类错题生成pdf打印纸质版，</p><p>最重要的是能长按排除选项，对于选择题来说很有用。</p><p>对了，我提到的都不是广，没有人会找我这种没粉丝的公众号投广告。</p><hr /><p>然后用喵刷刷了几乎所有的模拟卷的选择；肖八肖四选择题二刷三刷、纸质版刷完小程序刷；错题归档，打印纸质版继续二刷三刷。</p><p>背腿姐手册，背b站帕拉迪宇的一页纸，用政治带背下饭，</p><p>最后选择39，错仨单选，四多选。</p><p>挺烂，我记得今年出来之后很多人说政治选择简单。</p><hr /><p>政治选择方面应该很少人能超过我花费的时间。</p><p>你看，这可怜的投入产出比，（笑）。</p><p>不过我记得肖八刚出来的时候我第一套选择19分，大家平均也在一二十分左右，</p><p>该看的还是得看看，才能上40，</p><p>我意思就是该刷的刷，别刷多了。</p><p>十二月只刷肖八肖四吧各位，刷多了也没用。</p><p>反正大家水平都差不多之后，主要还是看运气。</p><hr /><p>平常互联网键政的各位，尤其是魔怔人，</p><p>我建议你们前期也不用买核心考案听徐涛的课了，很多概念你们都懂，</p><p>不懂的东西到十一二月的时候对着背诵手册细品一下也就明白了，很多都是你们平常唠的东西。</p><hr /><h3 id="大题">1.2 大题</h3><p>我这可怜的25分，我分析的是，</p><ul><li>京区主观狠压分</li><li>字体巨无敌烂</li><li>套张修齐模板抄材料少</li></ul><hr /><p>我现在挺后悔的，每天挂嘴边的就是京区把我害惨了，</p><p>放别的水区政英高二十分，调剂得多好调，</p><p>这就是当时不考虑退路的下场。</p><hr /><p>字体巨无敌烂这一点我也没想到，我没想到威海职业学院那几天那么冷，</p><p>前一天刚下完持续几周的雪，后一天就开始考试，化雪的同时考场还是没暖气的阶梯教室，</p><hr /><p>备考的时候要不还是找找适合你考场的温度吧，</p><p>像我，所有备考的时间为了不让身体状态影响我，都选择的是冬暖夏凉的图书馆，</p><p>导致我在20℃图书馆里模拟的政治字体间距排版等等一切，在零下的考场上全部失效。</p><hr /><p>买了四五十个暖宝宝，那两天全用完了，到处都贴，只能管前一小时，手还是冻僵握不住笔。</p><p>写的时候很难受，</p><p>我因为背的张修齐，每道题能写上的东西极其的多，我不想放过任何一个得分点，就把每一个答题空都写上了密密麻麻的蝇头小字，最后看我的答题卡，可以算是乌黑一片，</p><p>手冻僵了完全控制不了，同时肾上腺素作用，我边发抖边写字，这种情况下也没办法控制字体。</p><p>最后就是这个结果。</p><hr /><p>最后一点，</p><p>我觉得张修齐老师确实很好，直播点拨的答题思路经常让人恍然大悟，</p><p>娱乐性也强，懂得都懂，</p><p>十页纸也很好用，覆盖考研大题，减少了绝大部分背诵负担。</p><p>考水区的可以放心跟张修齐老师。</p><p>考旱区的话，我建议是肖八肖四也得看看，结合材料，自己组织语言和答分点，简洁清晰的卷面更重要。</p><hr /><p>还是那句话，你到十一二月再开政治完全不迟。</p><hr /><figure><img src="/images/image-20240302191735961.png"alt="image-20240302191735961" /><figcaption aria-hidden="true">image-20240302191735961</figcaption></figure><h2 id="英语">2.英语</h2><p>完型全对，阅读错仨，主观小作文6.5/10，大作文11/20，翻译7/10，只能说难评，京区就这样。</p><hr /><h3 id="客观">2.1 客观</h3><p>四六级裸考均分580，属于英语没那么好，但也不用额外补的水平。</p><p>单词没背完，太多了，红宝书那么一厚本我是真难绷，不背单词显示有六千多个？</p><p>我寻思着光单单在软件上按完就得花我一辈子。</p><hr /><p>后来只在不背单词上随便选了一个只有七八百的考研核心词的词书，</p><p>也没背完，最后剩了二百多个。</p><p>我的经验是还是得三人组队，找俩比较好的朋友，互相监督，不然我根本没时间打开软件。</p><p>当时主要背单词的时间都是在组队的那一个月背的，每天背十五分钟打卡，打完立马关了。</p><hr /><p>真题大概做了不到十套，</p><p>十月份的时候先做的10、11年的，当时完型动辄错11、12个，气笑了，就没再管，因为知道那段年份难。</p><p>后来十一月有空的时候做了几套近几年的选择，觉得阳间了不少，</p><p>完型稳定在两三个，阅读稳定在三四个，</p><p>当时实在是没时间，寻思着既然这水平能用了，就这样得了。</p><p>所以最后考试前那一个月也没做一两套英语，全吃老本。</p><hr /><p>最后证明运气还行，考场上的文章都能看懂，花二十分钟做完了客观题。</p><hr /><h3 id="主观">2.2 主观</h3><hr /><p>大作文用的红果研王晶婷的作文书，实在是很好用，</p><p>像拼图一样，可以选用不同水平的句子拼凑出属于自己的模板，</p><p>但主要还是靠当场发挥。</p><hr /><p>小作文搁十二月份背背那几个信件类型开头结尾的句式就行，</p><p>我感觉考研从我这届开始变得变化莫测了，试图考前压中题目是极其吃力不讨好的事儿，</p><p>中间的部分还不如当场发挥。</p><hr /><p>十一二月开始，大小作文分别模了两三次吧，平常就背背自己攒的模板。</p><hr /><p>翻译没啥说的，感觉无论翻译的再好在北京都会每道题扣0.5。</p><hr /><p>小作文写跑题了，</p><p>人外国人说要做一个ancientscientist的讲座，关于古代中国科学家的讲座，</p><p>按理说应该推荐中国古代的科学家，所以舍友问我写的谁的时候我汗流浃背，</p><p>我看成是面向研究中国古代文明的科学家做中文讲座，</p><p>写让他去bilibili学汉语，让他别担心，中国人都挺友善，你发音不准也不会嘲笑你，</p><p>跑题了还有6.5，可能把批试卷的研究生逗乐了。</p><hr /><p>大作文也挺逗，</p><p>各路老师考前预测，还是如同一成不变的往年，英一还是看图写话类作文，英语二还是图表类作文，</p><p>然后今年发下试卷来，我看了一眼大作文，</p><p>嘿，图片和图表都有，又给我气笑了。</p><p>图片好像是一座公园，游人自得其乐，图表是公园数量逐年上涨。</p><p>凭着仅有的对于图表趋势性描述的记忆简单写了几句。</p><p>后来就是赞颂Party好，government好，人民生活幸福感高，经济稳中向好。</p><p>不然还能说什么呢。</p><hr /><p>总之英语我几乎没花时间，对我来说是性价比爆棚的学科，</p><p>这大概就是那些大佬学数学的感受。</p><hr /><figure><img src="/images/image-20240302202850572.png"alt="image-20240302202850572" /><figcaption aria-hidden="true">image-20240302202850572</figcaption></figure><hr /><h2 id="数学">3 数学</h2><p>这个部分，我都痛苦的不想回忆它。</p><figure><img src="/images/image-20240302212124335.png"alt="image-20240302212124335" /><figcaption aria-hidden="true">image-20240302212124335</figcaption></figure><hr /><p>选择错仨，填空错仨，30分就已经没了。</p><p>极其恐怖。</p><p>我最后还能考97，全靠大题判卷放水。</p><hr /><p>所以那个上交佬在数学篇的一开始就说，</p><blockquote><p>数学是一门方差极大的学科，这个方差既指考生之间的方差，又指考生（发挥）的方差。</p></blockquote><p>我觉得能考到145-150的人，最低也就140，这只是试卷的上限，不是他深厚积累的底线。</p><p>但是在120，110，100分数段的人，完全可以考到90。</p><hr /><p>太痛苦了，是想想就想死的程度。</p><p>如果我备考有100%的时间，</p><p>那么60%的时间都在学数学，</p><p>30%的时间学408四门课，</p><p>8%的时间学政治，</p><p>2%的时间学英语。</p><hr /><p>性价比低到了一个令人咋舌的程度，感觉我学一两个月和我学一年相比，分差也不会超过20。</p><hr /><p>基础和强化全程跟的张宇，</p><p>我觉得没必要一听别人说张宇的课门槛高就退缩，我这种大学高数60分的人都能正常听懂，门槛高又能高到哪儿去呢。</p><p>线代大后期又跟了b站的帕拉迪宇，小铜数学等一系列优秀up主，</p><p>反正他们互相认识也合作过视频，找到一个就可以顺藤摸瓜找到其他人。</p><p>概率论和无穷级数到大后期又跟了一遍方浩。</p><p>记得不要跟考研竞赛凯哥，具体原因自己去找。</p><hr /><p>邂逅遗憾知乎的经验贴害惨了我，让我觉得我也能上，建议看他经验贴之前撒泡尿照照自己。</p><p>rw现在每年炸成这样，有很大一部分原因就是他知乎的经验帖。</p><p>但是他经验帖写的确实好，他推荐的方浩概率论确实不错，</p><p>他自己办的课挺贵的，小班八百多大班四千多，我没听过不做评价。</p><hr /><p>就是方浩的那个书和他的课程不配套真的很烦，我学概率论的时候一大部分时间都在抄他的课上例题，因为题确实有用，</p><p>尤其是张宇的课和他的书配套的极其丝滑，再听方浩的课感觉跟吔了史一样。</p><p>建议别买方浩的书，直接买风中易小生做的方浩做题本自己打印，我也是后来才发现风中易小生的做题本都给整理好了。</p><hr /><p>我虽然考得烂，但张宇老师确实好，教材做得很全，</p><p>上课生动形象，体谅学生，到现在我还记得他讲的狮子王的故事，不过当时听的时候我倍速过去了。</p><p>据说今年数学这样之后各大经验贴都主推张宇老师了，因为张宇老师的全程班基础性好的同时扩展度最高。</p><hr /><p>只能说从此往后，如果卷考研的人继续增多，数学的难度和扩展性也会越来越大，越来越起到选拔人才的作用，</p><p>今年就是最好的例子，狠狠给了我当头一棒，</p><p>没有两把刷子的人好好掂量掂量自己。</p><hr /><p>武老师我是真听不进去，语调太平，感觉像是大学里读ppt的老师，但是有很多跟武老师的人分数也很高，所以这两大派系的选择主要还是看自己。</p><hr /><p>周围基础不好的有跟周洋鑫的，</p><p>我本来不太了解这个人，就是最后的时候做了他出的三套卷，</p><p>猛然觉得，嗬这题出得好像真题，好有水平，然后一看发现很多都是真题改编的。</p><p>感觉应该也是个好老师。</p><hr /><p>我现在回忆，基础阶段和强化阶段在我脑海里是空白的，</p><p>我觉得这有可能就是我数学考成这个样子的原因。</p><p>像是盘古还未开天辟地时的混沌。</p><hr /><h2 id="section">4.408</h2><figure><img src="/images/image-20240302230426611.png"alt="image-20240302230426611" /><figcaption aria-hidden="true">image-20240302230426611</figcaption></figure><hr /><p>最后来个总结吧，再低也是我辛辛苦苦考出来的分</p><p>这个系统我这辈子估计也不会再进了。</p><p>（未写完，图之后贴）</p><figure><img src="/images/image-20240302230509125.png"alt="image-20240302230509125" /><figcaption aria-hidden="true">image-20240302230509125</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重新搞了博客</title>
    <link href="/2024/02/29/%E9%87%8D%E6%96%B0%E6%90%9E%E4%BA%86%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/02/29/%E9%87%8D%E6%96%B0%E6%90%9E%E4%BA%86%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>重新搞了博客，</p><p>21年刚开始整博客的时候，把博客放在了我自己的云服务器里，觉得既然买了就不用白不用，顺便练练运维啥的。</p><p>后来那个服务器承担了我很多的学习任务和尝试，所以经常遇到依赖地狱，</p><p>一旦十几个小时卡在某个依赖上毫无进展，我就直接气得重装整个服务器，</p><p>又懒得在外边套docker，所以连带着博客也得重装，我的评价是活该，</p><p>重装了几次之后就气坏了，懒得搞了，荒废了两年。</p><hr /><p>最终决定将博客作为一个lifelong的项目维持，为了省钱省力气挂在了github上，再重定向到我原来的域名，一举两得。</p><hr /><p>以前是把公众号的内容都搬过来，但是现在没那精力了，</p><p>因为微信公众号不支持md格式，导致我每次写完md之后还要贴到公众号上去精修一下，后来就演变成md只写草稿，再粘贴到公众号的编辑框写详细。</p><p>所以要么写个脚本，发哪个平台就全自动化移植到另一个平台，要么就两个平台单独更新吧，这边写点儿那边不让写的。</p><p>有空的时候我还是想完全自己写博客的前后端，现在用hexo主要是没时间，至于什么时候有时间，我觉得得等到上研究生之后，或者工作之后，或者退休之后了。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>标题</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>Hello there!👋</p><p>My name is LT, a senior Computer Science and Technology major atShandong University.</p><p>I have a passion for all things computer-related.</p><p>Besides being a techie, I'm also an avid movie buff and a dedicatedreader of novels.</p><p>You can think of me as a cyber hamster🐹, perpetually scurryingthrough the boundless corridors of the internet.</p><p>I run my own public WeChat account "LT想吃黑芝麻汤圆,"</p><p>My amateur radio call sign is BI4ISA,</p><p>and I am on my journey to becoming a full-stack engineer.👩🏻‍💻</p><p>Should you wish to reach out, my email is sdtaltt@163.com. I would bedelighted to connect.</p>]]></content>
    
  </entry>
  
  
  
</search>
