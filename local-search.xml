<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>全方位展示一下我人生中第一块PCB🥹</title>
    <link href="/2024/03/12/%E5%85%A8%E6%96%B9%E4%BD%8D%E5%B1%95%E7%A4%BA%E4%B8%80%E4%B8%8B%E6%88%91%E4%BA%BA%E7%94%9F%E4%B8%AD%E7%AC%AC%E4%B8%80%E5%9D%97PCB/"/>
    <url>/2024/03/12/%E5%85%A8%E6%96%B9%E4%BD%8D%E5%B1%95%E7%A4%BA%E4%B8%80%E4%B8%8B%E6%88%91%E4%BA%BA%E7%94%9F%E4%B8%AD%E7%AC%AC%E4%B8%80%E5%9D%97PCB/</url>
    
    <content type="html"><![CDATA[<p>以为毕设要做出一个成品来，</p><p>于是认真地把板子大小缩了再缩，最后缩到55mm*66mm，</p><p>这么大点儿空，布线差点儿布emo，</p><p>选的都是贴片类型的元件，全贴在PCB上，甚至还打算加装一个外壳，</p><p>为了缩减成本，选料也选了一阵子，最终缩减到104，</p><p>然后打算SMT的时候发现最少贴俩，材料费200多，加工费400多。</p><p><br></p><p>汗流浃背，问老师咋整，</p><p>——要不我用用咱院里的电焊，买材料回来自己焊？</p><p><br></p><p>老师也汗流浃背，说——</p><p>其实不用做出成品，写在论文里就行。</p><p><br></p><p>最后决定用嵌入式课程发的单片机简单实现一下。</p><p>嵌入式主要感谢这个教程</p><p><ahref="https://www.bilibili.com/video/BV1HH4y1o7EN/?spm_id_from=333.880.my_history.page.click&amp;vd_source=e404ad14246992bcc3e4ac52a33df8ed">小白物联网智能家居毕设参考STM32+ESP8266/MQTT+OneNet+UniApp_哔哩哔哩_bilibili</a></p><p><br></p><p><br></p><p>但我好不容易整出来了，还是得展示一下。</p><p><br></p><h3 id="原理图">原理图</h3><p>右上角是我从嘉立创随便找的开源stm32最小系统板，</p><p><ahref="https://oshwhub.com/dian-xie-eda/stm32f103c8t6">STM32F103C8T6 -嘉立创EDA开源硬件平台 (oshwhub.com)</a></p><p>除了stm32之外的是我自己整的，</p><p>此处感谢这几个教程</p><p><ahref="https://www.bilibili.com/video/BV1fM411Z7cW?p=1&amp;vd_source=e404ad14246992bcc3e4ac52a33df8ed">00-0-课程介绍_哔哩哔哩_bilibili</a></p><p><ahref="https://www.bilibili.com/video/BV13d4y1L7Rg/?spm_id_from=333.788&amp;vd_source=e404ad14246992bcc3e4ac52a33df8ed">带着你从手册开始画板STM最小系统板教程系列(一)_哔哩哔哩_bilibili</a></p><p><ahref="https://www.bilibili.com/video/BV12M4y1N7MZ/?spm_id_from=333.880.my_history.page.click&amp;vd_source=e404ad14246992bcc3e4ac52a33df8ed">09STM32F103C8T6最小系统_哔哩哔哩_bilibili</a></p><figure><img src="/images/image-20240312155432510.png"alt="image-20240312155432510" /><figcaption aria-hidden="true">image-20240312155432510</figcaption></figure><h3 id="pcb布局">PCB布局</h3><p>按模块随便布的</p><figure><img src="/images/Snipaste_2024-03-11_22-05-04.png"alt="Snipaste_2024-03-11_22-05-04" /><figcaption aria-hidden="true">Snipaste_2024-03-11_22-05-04</figcaption></figure><h3 id="飞线">飞线</h3><p>事实上我也不会飞，就是随便来，疯狂过孔，没有什么是过孔解决不了的（</p><figure><img src="/images/Snipaste_2024-03-12_11-30-01.png"alt="Snipaste_2024-03-12_11-30-01" /><figcaption aria-hidden="true">Snipaste_2024-03-12_11-30-01</figcaption></figure><p>这时候就有内味儿了</p><p><img src="/images/Snipaste_2024-03-12_12-08-57.png"alt="Snipaste_2024-03-12_12-08-57" /><imgsrc="/images/Snipaste_2024-03-12_12-15-41.png"alt="Snipaste_2024-03-12_12-15-41" /></p><p>又去听了听教程，然后发现晶振里边走线不太好，紧急修改（</p><figure><img src="/images/Snipaste_2024-03-12_12-28-57.png"alt="Snipaste_2024-03-12_12-28-57" /><figcaption aria-hidden="true">Snipaste_2024-03-12_12-28-57</figcaption></figure><h3 id="覆铜">覆铜</h3><p><del>覆完感觉自己牛得不得了</del></p><figure><img src="/images/Snipaste_2024-03-12_12-48-11.png"alt="Snipaste_2024-03-12_12-48-11" /><figcaption aria-hidden="true">Snipaste_2024-03-12_12-48-11</figcaption></figure><figure><img src="/images/image-20240312160729545.png"alt="image-20240312160729545" /><figcaption aria-hidden="true">image-20240312160729545</figcaption></figure><h3 id="d模型">3D模型</h3><figure><img src="/images/Snipaste_2024-03-12_15-22-45.png"alt="Snipaste_2024-03-12_15-22-45" /><figcaption aria-hidden="true">Snipaste_2024-03-12_15-22-45</figcaption></figure><figure><img src="/images/Snipaste_2024-03-12_15-22-53.png"alt="Snipaste_2024-03-12_15-22-53" /><figcaption aria-hidden="true">Snipaste_2024-03-12_15-22-53</figcaption></figure><h3 id="打样">打样</h3><figure><img src="/images/Snipaste_2024-03-12_15-21-46.png"alt="Snipaste_2024-03-12_15-21-46" /><figcaption aria-hidden="true">Snipaste_2024-03-12_15-21-46</figcaption></figure><figure><img src="/images/Snipaste_2024-03-12_15-21-19.png"alt="Snipaste_2024-03-12_15-21-19" /><figcaption aria-hidden="true">Snipaste_2024-03-12_15-21-19</figcaption></figure><p>最后选的白色，<del>因为感觉白色碉堡了</del></p><h3 id="一些细节图">一些细节图</h3><figure><img src="/images/image-20240312161133819.png"alt="image-20240312161133819" /><figcaption aria-hidden="true">image-20240312161133819</figcaption></figure><figure><img src="/images/image-20240312161149861.png"alt="image-20240312161149861" /><figcaption aria-hidden="true">image-20240312161149861</figcaption></figure><figure><img src="/images/image-20240312161240286.png"alt="image-20240312161240286" /><figcaption aria-hidden="true">image-20240312161240286</figcaption></figure><p>结语：</p><p>虽然我连电路模电都没学过，但感觉当个layout工程师也挺好的....连线的时候感觉好治愈哦🥹</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DAY5日寄-数据标注-力扣刷题-PCB布局</title>
    <link href="/2024/03/11/DAY5/"/>
    <url>/2024/03/11/DAY5/</url>
    
    <content type="html"><![CDATA[<ol type="1"><li><strong>图像预处理</strong>：<ul><li>裁剪图像：如有需要，可以裁剪原始图像，分离出单个工件。</li><li>增强对比度：通过调整亮度和对比度凸显毛刺与工件表面的差异。</li><li>去噪：使用滤波器减少或消除图像噪声，如高斯模糊、中值滤波等。</li></ul></li><li><strong>分割工件</strong>：<ul><li>阈值分离：使用全局或自适应阈值分离工件与背景。</li><li>边缘检测：应用如Canny、Sobel等算法检测工件边缘。</li><li>区域生长或轮廓搜寻：依据边缘信息寻找单独工件的轮廓。</li></ul></li><li><strong>特征提取</strong>：<ul><li>形状分析：提取工件的几何形状特征来识别是否存在毛刺。</li><li>纹理分析：检查毛刺区域的纹理变化，毛刺可能导致纹理不连续。</li></ul></li><li><strong>毛刺检测</strong>：<ul><li>串标定位：利用形状或纹理特征定位可能的毛刺区域。</li><li>模式识别：使用机器学习或深度学习模型（如卷积神经网络）来分类和识别含有毛刺的区域。</li></ul></li><li><strong>后处理</strong>：<ul><li>结果评价：分析检测结果，评价毛刺的位置、大小和严重程度。</li><li>结果优化：根据评价结果调整算法参数，以提高检测的准确率和可靠性。</li></ul></li><li><strong>软件实现</strong>：<ul><li>编写代码：根据所选择的算法使用编程语言（例如Python、C++）和图像处理库（如OpenCV）编写代码。</li><li>测试验证：在多个图像上测试你的代码，验证检测的准确性和效率。</li></ul></li></ol><figure><img src="/images/image-20240311103057188.png"alt="image-20240311103057188" /><figcaption aria-hidden="true">image-20240311103057188</figcaption></figure><p>只能手动套索分割，这下真成数据分割女工了</p><p>早知道当初拍照的时候就不图方便放在一起了</p><p>的研究兴趣包括：</p><ol type="1"><li><strong>多模态数据建模和下一代人机界面的基础模型应用</strong></li><li><strong>时间序列和序列数据上的机器学习</strong></li><li><strong>基于大型语言模型的自主决策代理</strong></li></ol><p>他的研究涉及到机器学习和强化学习在数据科学中的应用，所以如果您在这些方面有研究兴趣和实力，特别是对时间序列和序列数据相关的研究感兴趣，或者对如脑机界面、医疗保健、金融和推荐系统等领域的应用感兴趣，那么与合作研究可能非常适合您。</p><h3id="检测一个整个文件夹中所有图像是否为rgb格式">检测一个整个文件夹中所有图像是否为RGB格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br><span class="hljs-comment"># 替换为你的文件夹路径</span><br>folder_path = <span class="hljs-string">&#x27;D:\\QQ\\QQ数据\\1409757351\\FileRecv\\test(1)\\test\\11\\vott-json-export&#x27;</span><br><br><span class="hljs-comment"># 列出文件夹中的所有文件</span><br>files = os.listdir(folder_path)<br><br><span class="hljs-comment"># 遍历文件检查每个图像</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>    <span class="hljs-comment"># 构建完整的文件路径</span><br>    file_path = os.path.join(folder_path, file)<br>    <span class="hljs-comment"># 确保是文件且符合图像格式</span><br>    <span class="hljs-keyword">if</span> os.path.isfile(file_path) <span class="hljs-keyword">and</span> file_path.lower().endswith((<span class="hljs-string">&#x27;.png&#x27;</span>, <span class="hljs-string">&#x27;.jpg&#x27;</span>, <span class="hljs-string">&#x27;.jpeg&#x27;</span>)):<br>        <span class="hljs-comment"># 打开图像</span><br>        image = Image.<span class="hljs-built_in">open</span>(file_path)<br>        <br>        <span class="hljs-comment"># 检查图像模式</span><br>        <span class="hljs-keyword">if</span> image.mode == <span class="hljs-string">&#x27;RGB&#x27;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;图像 &quot;<span class="hljs-subst">&#123;file&#125;</span>&quot; 是三通道RGB格式。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;图像 &quot;<span class="hljs-subst">&#123;file&#125;</span>&quot; 不是三通道RGB格式。当前格式为: <span class="hljs-subst">&#123;image.mode&#125;</span>&#x27;</span>)<br>            <span class="hljs-comment"># 如果需要将非RGB图像转换为RGB</span><br>            image = image.convert(<span class="hljs-string">&#x27;RGB&#x27;</span>)<br>            image.save(file_path)  <span class="hljs-comment"># 保存转换后的图像</span><br></code></pre></td></tr></table></figure><h3 id="双指针移除元素">双指针移除元素</h3><p>由于题目要求删除数组中等于 valval的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针rightright 指向当前将要处理的元素，左指针 leftleft指向下一个将要赋值的位置。</p><p>如果右指针指向的元素不等于valval，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</p><p>如果右指针指向的元素等于valval，它不能在输出数组里，此时左指针不动，右指针右移一位。</p><p>整个过程保持不变的性质是：区间 [0,left)[0,)[0,left) 中的元素都不等于valval。当左右指针遍历完输入数组以后，leftleft的值就是输出数组的长度。</p><p>这样的算法在最坏情况下（输入数组中没有元素等于valval），左右指针各遍历了数组一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> oldlength=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(right&lt;oldlength)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[right]!=val)<br>            &#123;<br>                nums[left]=nums[right];<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="原地删除重复项">原地删除重复项</h3><p>while 右指针小于数组长度</p><p>if 左指针和右指针相等</p><p>右指针加一，左指针不变</p><p>else 左右指针不相等</p><p>左指针加一，左指针等于右指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> length=nums.<span class="hljs-built_in">size</span>();<br>      <span class="hljs-keyword">while</span>(right&lt;length)<br>      &#123;<br>           <span class="hljs-keyword">if</span>(nums[left]==nums[right])<br>               right++;<br>           <span class="hljs-keyword">else</span><br>               &#123;<br>                   left++;<br>                   nums[left]=nums[right];<br>               &#125;<br>      &#125; <br>      <span class="hljs-keyword">return</span> ++left;<br>   &#125;<br></code></pre></td></tr></table></figure><figure><img src="/images/image-20240311184429988.png"alt="image-20240311184429988" /><figcaption aria-hidden="true">image-20240311184429988</figcaption></figure><p>庆祝我人生中第一道自己做出来的力扣easy题🥹</p><h3 id="验证回文串">验证回文串：</h3><p>大写转小写：ascii码</p><p>移除非数字字母字符：</p><p>reverse 看对不对</p><p>主要就是考察C++字符串处理的库函数的应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">isalnum</span>(c)  <span class="hljs-comment">// 当是字母或数字时为真</span><br><span class="hljs-built_in">isalpha</span>(c)  <span class="hljs-comment">// 当是字母时为真</span><br><span class="hljs-built_in">isdigit</span>(c)  <span class="hljs-comment">// 当是数字是为真</span><br><span class="hljs-built_in">islower</span>(c)  <span class="hljs-comment">// 当是小写字母时为真</span><br><span class="hljs-built_in">isupper</span>(c)  <span class="hljs-comment">// 当是大写字母时为真</span><br><span class="hljs-built_in">isspace</span>(c)  <span class="hljs-comment">// 当是空白（空格、回车、换行、制表符等）时为真</span><br><span class="hljs-built_in">isxdigit</span>(c) <span class="hljs-comment">// 当是16进制数字是为真</span><br><span class="hljs-built_in">ispunct</span>(c)  <span class="hljs-comment">// 当是标点符号时为真（即c不是 控制字符、数字、字母、可打印空白 中的一种）</span><br><span class="hljs-built_in">isprint</span>(c)  <span class="hljs-comment">// 当时可打印字符时为真（即c是空格或具有可见形式）</span><br><span class="hljs-built_in">isgraph</span>(c)  <span class="hljs-comment">// 当不是空格但可打印时为真</span><br><span class="hljs-built_in">iscntrl</span>(c)  <span class="hljs-comment">// 当是控制字符时为真</span><br><span class="hljs-built_in">tolower</span>(c)  <span class="hljs-comment">// 若c是大写字母，转换为小写输出，否则原样输出</span><br><span class="hljs-built_in">toupper</span>(c)  <span class="hljs-comment">// 类似上面的</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string sgood;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch: s) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalnum</span>(ch)) &#123;<br>                sgood += <span class="hljs-built_in">tolower</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-function">string <span class="hljs-title">sgood_rev</span><span class="hljs-params">(sgood.rbegin(), sgood.rend())</span></span>;<br>        <span class="hljs-keyword">return</span> sgood == sgood_rev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="多数元素">多数元素</h3><p>一维数组是不彳亍的，不仅空间用的多还会超时</p><figure><img src="/images/image-20240311200129691.png"alt="image-20240311200129691" /><figcaption aria-hidden="true">image-20240311200129691</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            a[nums[i]]++;<br>        &#125;<br>        <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;j&lt;<span class="hljs-number">100</span>;j++)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(a[j]&gt;max)<br>                max=a[j],k=j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; counts; <span class="hljs-comment">// 使用map来存储元素及其出现次数</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 统计每个数字出现的次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>        &#123;<br>            counts[nums[i]]++;<br>        &#125;<br>        <span class="hljs-comment">// 找出多数元素</span><br>        <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 第一个int保存元素值，第二个int保存出现次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;count : counts) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (count.second &gt; n / <span class="hljs-number">2</span>) <br>            &#123;<br>                majorityElement = count;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 多数元素定义为超过总数一半的元素，所以可以在找到后直接终止循环</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> majorityElement.first;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我甚至不知道还有map这个二维存储的东西，真是太菜了</p><h3 id="c-中的字符串数组">C ++中的字符串数组</h3><figure><img src="/images/image-20240311201533870.png"alt="image-20240311201533870" /><figcaption aria-hidden="true">image-20240311201533870</figcaption></figure><figure><img src="/images/image-20240311202006704.png"alt="image-20240311202006704" /><figcaption aria-hidden="true">image-20240311202006704</figcaption></figure><figure><img src="/images/image-20240311201954203.png"alt="image-20240311201954203" /><figcaption aria-hidden="true">image-20240311201954203</figcaption></figure><p>作者：力扣官方题解链接：https://leetcode.cn/problems/remove-element/solutions/730203/yi-chu-yuan-su-by-leetcode-solution-svxi/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure><img src="/images/image-20240311203027539.png"alt="image-20240311203027539" /><figcaption aria-hidden="true">image-20240311203027539</figcaption></figure><p>滤波电容</p><figure><img src="/images/image-20240311203944816.png"alt="image-20240311203944816" /><figcaption aria-hidden="true">image-20240311203944816</figcaption></figure><p>复位引脚，默认永久上拉，按下按键低电平复位</p><p>刚上电的时候系统电容没电，引脚接地自动复位一次，电容充满之后上拉正常工作</p><p>电容充电的时候可以当作导线，充满了就成断路了</p><figure><img src="/images/image-20240311204658768.png"alt="image-20240311204658768" /><figcaption aria-hidden="true">image-20240311204658768</figcaption></figure><p>高频8MHz倍频之后72MHz，低频32.768kHz（2的整数次方 ）</p><figure><img src="/images/image-20240311210030212.png"alt="image-20240311210030212" /><figcaption aria-hidden="true">image-20240311210030212</figcaption></figure><figure><img src="/images/image-20240311210047560.png"alt="image-20240311210047560" /><figcaption aria-hidden="true">image-20240311210047560</figcaption></figure><p>滤波电容和外部晶振需要靠近芯片</p><p>线宽可以10</p><p>gnd可以先不连，空余的地方全铺上gnd（铺铜）</p><p>丝印，打槽</p><figure><img src="/images/image-20240311220549604.png"alt="image-20240311220549604" /><figcaption aria-hidden="true">image-20240311220549604</figcaption></figure><p>嗨嗨嗨！明天开始飞线！</p>]]></content>
    
    
    <categories>
      
      <category>日寄</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DAY4日寄-毕设电子-java面经</title>
    <link href="/2024/03/10/DAY4/"/>
    <url>/2024/03/10/DAY4/</url>
    
    <content type="html"><![CDATA[<h3id="在esp8266的vcc上添加电容是为了提供电压稳定减少电源噪声并帮助设备在突然的功率需求变化时保持稳定">在ESP8266的VCC上添加电容是为了提供电压稳定，减少电源噪声，并帮助设备在突然的功率需求变化时保持稳定。</h3><p>通常建议至少在VCC和地线之间使用一个10微法拉（10μF）的电解电容，以及一个0.1微法拉（0.1μF）的陶瓷电容。这两个电容相结合，能充分起到去耦和滤波的效果。</p><p>10μF的电容用于提供足够的储能，保证模块在射频发送过程中或CPU高速运行时能够获得稳定的电源。而0.1μF的电容起到了迅速对高频噪声的滤除作用。根据您具体电路环境的不同，还可能需要调整电容的大小，因此在设计电路时，根据实际的电源质量和电路情况进行测试和调整是非常必要的。如果条件允许，最好通过实验来确定最佳容量值。</p><p>高速晶振产生系统时钟，低俗晶振向RTC提供时钟</p><p>stm32本身也有时钟，如果检测到有外部时钟就用外部，但是没有高速的，到不了72MHz，</p><p>在正负极之间加去耦合电容，防止信号干扰</p><p>PA13和PA14口连接STLink进行debug下载，下载进去之后可以禁用，变成普通的管脚使用</p><p>禁用了还想下载的话复位一下马上点下载</p><p>一般用sw不用jtag是因为用的线少，</p><p>VBAT也可以接1.8v，但其实此时内部内核没有工作</p><figure><img src="/images/image-20240310194203101.png"alt="image-20240310194203101" /><figcaption aria-hidden="true">image-20240310194203101</figcaption></figure><figure><img src="/images/image-20240310195825291.png"alt="image-20240310195825291" /><figcaption aria-hidden="true">image-20240310195825291</figcaption></figure><figure><img src="/images/image-20240310200411202.png"alt="image-20240310200411202" /><figcaption aria-hidden="true">image-20240310200411202</figcaption></figure><figure><img src="/images/image-20240310202342018.png"alt="image-20240310202342018" /><figcaption aria-hidden="true">image-20240310202342018</figcaption></figure><p>boot1直接下拉，（下拉电阻10k）地线</p><p>boot0默认是0（直接下拉），按下按键变为高电平</p><p>VBAT脚是电池供电脚，如果接入1.8V~3.6V可保证后备区工作，用于在休眠时保存RAM空间的变量，当然需要在休眠前将变量写入后备区空间。</p><p>最小系统额定电流是200mA，所以没办法驱动大功率的东西，比如电机，需要重新设计</p><figure><img src="/images/image-20240310194017107.png"alt="image-20240310194017107" /><figcaption aria-hidden="true">image-20240310194017107</figcaption></figure><p>用isp下载需要来回切换跳线</p><h3 id="java面经整理">Java面经整理</h3><p>特点：面向对象，封装继承多态，平台无关，支持多线程，异常处理，自动内存管理，编译与解释共存</p><p>JVM：java虚拟机，一次编写，多次运行，</p><p>JDK：开发套件，包括JRE等</p><p>JRE：运行环境，包括java虚拟机和java基础类库</p><p>不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK</p><figure><img src="/images/image-20240310113056177.png"alt="image-20240310113056177" /><figcaption aria-hidden="true">image-20240310113056177</figcaption></figure><p>从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了</p><p>JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像</p><p>JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>当 JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>执行次数越多，速度越快。</p><figure><img src="/images/image-20240310113601833.png"alt="image-20240310113601833" /><figcaption aria-hidden="true">image-20240310113601833</figcaption></figure><p><strong>AOT(Ahead of Time Compilation)</strong> 。和 JIT不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译</p><p>AOT 的主要优势在于启动时间、内存占用和打包体积。JIT的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p><p>Oracle JDK 和 OpenJDK 的区别：</p><p>open开源，oracle不开源，oracle是open的升级版</p><h4 id="javac区别">javac++区别</h4><p>Java 不提供指针来直接访问内存，程序内存更加安全</p><p>Java 的类是单继承的，C++ 支持多重继承；虽然 Java的类不可以多继承，但是接口可以多继承。</p><p>Java有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</p><p>C ++同时支持方法重载和操作符重载，但是 Java只支持方法重载（操作符重载增加了复杂性，这与 Java最初的设计思想不符）。</p><p>所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</p><p><code>default</code>这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p><p>Java中的字面值（Literals）是指在代码中直接表示的固定值，可以直接被编译器识别的常数。Java中的字面值可以分为几种基本类型：</p><ol type="1"><li>整数字面值：表示整数值（如 1, 2,100），可以是十进制、十六进制、八进制或二进制形式。</li><li>浮点数字面值：表示浮点数值（如 1.234,3.14e-2），可以是十进制或科学计数法形式。</li><li>字符字面值：表示单个字符的值，用单引号括起来（如 'a', '3',''）。</li><li>字符串字面值：表示字符串的值，用双引号括起来（如 "Hello","123"）。</li><li>布尔字面值：表示布尔值，只有两个：true 和 false。</li><li>空字面值（null）：表示一个空引用，不能直接赋给基本类型的变量。</li></ol><p>字面值是不可变的；它们的值在编写代码的时候就被确定，并直接嵌入到代码执行时的指令序列中。</p><p>你所提及的 true, false, 和 null确实看起来像关键字，但像你说的，它们是预定义的字面值。因此，它们不能用作标识符，即不能被用作变量名、方法名或其他标识符名称。Java编译器会将它们识别为具有特定含义的固定值，而非可变的实体。</p><ul><li><code>&lt;&lt;</code>:左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于x 乘以 2(不溢出的情况下)。</li><li><code>&gt;&gt;</code>:带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li><li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0补齐。</li></ul><p>由于 <code>double</code>，<code>float</code>在二进制中的表现比较特殊，因此不能来进行移位操作。</p><p><strong>如果移位的位数超过数值所占有的位数会怎样？</strong></p><p>当 int 类型左移/右移位数大于等于 32位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p><p>也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x &gt;&gt;&gt;42</code>等同于<code>x &gt;&gt;&gt; 10</code>。</p><p>Java的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一</p><ol type="1"><li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上<strong>L</strong>，否则将作为整型解析。</li><li><code>char a = 'h'</code>char:单引号，<code>String a = "hello"</code> :双引号。</li></ol><p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议原文链接：https://javaguide.cn/java/basis/java-basic-questions-01.html</p>]]></content>
    
    
    <categories>
      
      <category>日寄</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>配置博客自动改图片路径和自动剪切图片的尝试</title>
    <link href="/2024/03/09/try/"/>
    <url>/2024/03/09/try/</url>
    
    <content type="html"><![CDATA[<h3 id="解释一下这一句regex-r..">解释一下这一句regex =r'![.<em>?]((.</em>?))'</h3><p>这个正则表达式是用来匹配Markdown文档中图片链接格式的。</p><p>让我们逐步分解一下这个正则表达式：</p><ul><li><code>!</code>:在Markdown中，图片链接是以感叹号<code>!</code>开头的，所以正则表达式首先会查找感叹号。</li><li><code>[`: 紧跟着感叹号的是一个左方括号`[`，在正则表达式中方括号是一个特殊字符，用于定义字符集（character class）。因此，我们需要使用反斜杠</code>来转义它，以匹配文本中的实际方括号。<ul><li><code>.*?</code>:然后是点号<code>*</code>和问号<code>?</code>的组合。 -点号<code>.</code>代表任何单个字符（除了换行符）。 -星号<code>*</code>表示重复前面的字符零次或多次。 -问号<code>?</code>在这里是一个非贪婪（non-greedy）限定符，它告诉正则表达式引擎匹配尽可能少的字符，直到遇到下一个模式。</li><li><code>\]``: 这部分是查找与前面的左方括号相对应的右方括号</code>]`，同样地，由于方括号在正则表达式中有特殊含义，我们使用反斜杠``进行转义。</li></ul></li><li><code>\(</code>和<code>\)</code>:这两个是用来匹配实际的左右圆括号<code>(</code>和<code>)</code>，这两个圆括号用来括起Markdown中图片链接的URL路径，因为在正则表达式中圆括号具有特殊的分组功能，所以需要使用反斜杠<code>\</code>来转义它们。</li><li><code>(.*?)</code>: 这是一个捕获组（capturing group）：<ul><li>括号<code>()</code>定义了一个捕获组，用来捕获和存储匹配的数据以便将来引用。</li><li>点号<code>.*</code>同样表示匹配任何字符零次或多次。</li><li>问号<code>?</code>使得匹配变得非贪婪，即匹配尽量少的字符。</li></ul></li></ul><p>综上所述，正则表达式<code>r'!\[.*?\]\((.*?)\)'</code>整体查找的是一个标记了图片图像且不包含换行符的Markdown链接，它匹配以<code>![]</code>开始，紧跟一个括号内含任意字符（非贪婪匹配）的字符串。括号内的匹配部分（即图片的URL路径）被捕获以便之后使用。</p><h3id="我每次上传博客md文件和图像的话是需要g还是d">我每次上传博客md文件和图像的话是需要g还是d</h3><p>当你上传博客的Markdown文件和图像后，通常你需要先执行<code>hexo generate</code>（或其简写<code>hexo g</code>）来生成最新的静态文件，然后执行<code>hexo deploy</code>（或其简写<code>hexo d</code>）将这些静态文件部署到服务器上。</p><p>具体步骤通常是这样的：</p><ol type="1"><li>更新Markdown文件和图像到你的博客项目目录中。</li><li>在命令行中运行<code>hexo g</code>来生成网站的静态内容。这个过程会将你的Markdown和图像文件转换为网页文件，并将它们存放在<code>public</code>目录下。</li><li>完成网站的静态内容生成后，运行<code>hexo d</code>来部署这些内容到指定的服务器上，例如GitHubPages。</li></ol><p>如果你已经配置了Hexo的一键部署功能，在运行<code>hexo d</code>时，Hexo会自动将<code>public</code>目录中的内容推送到远程仓库，网站即会相应更新。</p><p>请记住，每次对博客内容做出更改，比如添加或编辑文章，或者更改图像等，你都需要运行这两个命令以确保你的更改被应用并展示在你的线上博客中。</p><h3id="error-cannot-spawn-.githookspre-commit-no-such-file-or-directory-everything-up-to-date-branch-master-set-up-to-track-gitgithub.comltspaceltspace.github.io.gitmaster.">error:cannot spawn .git/hooks/pre-commit: No such file or directory Everythingup-to-date branch 'master' set up to track'git@github.com:ltspace/ltspace.github.io.git/master'.</h3><p>这个错误信息表明Git在尝试执行<code>pre-commit</code>钩子时没有找到这个文件，这可能是由于以下几个原因造成的：</p><ol type="1"><li><code>pre-commit</code>钩子文件可能没有正确放置在<code>.git/hooks</code>目录中。</li><li><code>pre-commit</code>文件可能没有执行权限（在Windows环境下通常不需要设置执行权限，但有时可能受特定的环境配置影响）。</li><li>如果你使用Windows，并且手动创建了<code>pre-commit</code>文件，可能会不知不觉地给文件加上了默认的<code>.txt</code>等扩展名。</li></ol><p>针对以上情况，请检查以下几点：</p><ul><li>确认<code>pre-commit</code>文件位于正确的目录：<code>.git/hooks</code>。</li><li>确认文件名确实是<code>pre-commit</code>，没有隐藏的扩展名。在Windows文件资源管理器中查看文件名时，要确保设置允许显示已知文件类型的扩展名。</li><li>如果是通过文本编辑器创建的钩子脚本，确保在保存时选择“所有文件”类型，以避免自动添加扩展名。</li><li>尝试直接在命令行中执行<code>pre-commit</code>钩子脚本来看是否能正确运行。如果不能，可能是脚本本身存在问题，或者你的环境中没有安装Python或者脚本的执行路径不对（在脚本的开头<code>#!/bin/sh</code>可能需要指向正确的shell路径，这在Windows中通常不是必须的，但是依赖于你的环境配置）。</li></ul><p>如果上述都没问题，你可以尝试删除<code>pre-commit</code>钩子并重新创建它。如果错误仍然存在，那么需要对你的Git安装和配置环境做更深入的查看。在极端情况下，你可能需要重新安装Git或者调查是否有其它系统级的问题影响到了Git钩子的执行。</p><h3id="我的git仓库里.git的名字是.deploy_git是这个的原因吗">我的git仓库里.git的名字是.deploy_git，是这个的原因吗</h3><p>如果你的 <code>.git</code> 文件夹的名字被改为了<code>.deploy_git</code>，那很有可能是使用了Hexo的部署机制，特别是当采用<code>hexo-deployer-git</code>插件时，它会创建一个<code>.deploy_git</code>目录用来作为Git部署仓库。这个目录用于存储生成的静态文件，并将其推送到远程仓库，比如GitHubPages。</p><p><code>.deploy_git</code>目录与你本地编辑文档的Git仓库（通常用<code>.git</code>目录来管理）是分开的。Git钩子需要放在实际的Git仓库的<code>.git/hooks</code>目录中。如果你将钩子脚本放到了<code>.deploy_git</code>目录，那么它不会在你的常规Git操作中被触发。</p><p>解决方法如下：</p><ol type="1"><li>确认你的本地仓库（包含你编辑的源文件）的<code>.git</code>目录。它应该是你项目根目录的<code>.git</code>文件夹，而不是Hexo生成的<code>.deploy_git</code>文件夹。</li><li>将你的<code>pre-commit</code>钩子脚本放入你项目根目录下的<code>.git/hooks</code>目录中。</li><li>确保<code>pre-commit</code>钩子脚本具有正确的内容，并且能够在你尝试提交到你的源代码仓库时被触发。</li></ol><p>如果你尝试修改你的源代码并提交（例如使用<code>git commit</code>命令），那么钩子脚本应该在你项目的<code>.git/hooks</code>目录中被触发。如果你仅仅使用<code>hexo deploy</code>命令部署网站，它是不会触发这个钩子的，因为这通常会直接向<code>.deploy_git</code>仓库提交。</p><h3id="我发现我的.depoly_git里还有一个.git文件夹-这个文件夹又是干什么的">我发现我的.depoly_git里还有一个.git文件夹这个文件夹又是干什么的</h3><p>在Hexo项目中，<code>.deploy_git</code>文件夹是用于存储Hexo生成的静态文件以便部署到远程服务器的地方。当你使用<code>hexo-deployer-git</code>插件进行部署时，Hexo会将<code>public</code>目录中生成的静态文件复制到<code>.deploy_git</code>目录，并在该目录初始化一个新的Git仓库用于部署。</p><p><code>.deploy_git</code>目录中的<code>.git</code>文件夹是这个用于部署的Git仓库的元数据存储位置，其中包含了版本控制的相关信息，如分支、提交历史、配置等。实际上，<code>.deploy_git</code>目录本身就像是一个完整的Git仓库。</p><p>当你执行<code>hexo deploy</code>命令时，以下步骤会被触发：</p><ol type="1"><li>Hexo调用<code>hexo generate</code>生成静态文件。</li><li>生成的静态文件被复制到<code>.deploy_git</code>目录。</li><li>在<code>.deploy_git</code>目录执行Git命令，将变更添加(commit)到本地仓库，并将其推送(push)到远程服务器（如GitHubPages或其他托管服务）。</li></ol><p><code>.git</code>文件夹在<code>.deploy_git</code>目录中的作用是管理这一部署过程中所有的Git操作和历史记录。</p><p>如果你在尝试运行Git钩子时遇到问题，请确保钩子被放置于你的源代码仓库的<code>.git/hooks</code>目录中，而不是<code>.deploy_git</code>目录或其内的<code>.git</code>目录中。这样，当你操作源代码仓库时（比如执行<code>git commit</code>），钩子才会被正确触发。</p><figure><img src="/images/image-20240309112717007.png"alt="image-20240309112717007" /><figcaption aria-hidden="true">image-20240309112717007</figcaption></figure><h3id="我还需要额外再执行一遍git-commit的命令吗有没有方法让我只执行hexo-g--d">我还需要额外再执行一遍gitcommit的命令吗，有没有方法让我只执行hexo g -d</h3><p>如果要在执行 <code>hexo g -d</code> 的同时确保<code>pre-commit</code> 钩子被触发，你需要理解 <code>git commit</code>和 <code>hexo g -d</code> 在工作流程上的不同：</p><ul><li><code>git commit</code> 是Git版本控制系统的命令，当你执行它时会触发<code>.git/hooks</code> 中的钩子脚本。</li><li><code>hexo g -d</code>是Hexo的命令，用于生成静态网站内容并将其部署到配置的服务器上，不会直接触发Git的<code>pre-commit</code> 钩子。</li></ul><figure><img src="/images/image-20240309114430069.png"alt="image-20240309114430069" /><figcaption aria-hidden="true">image-20240309114430069</figcaption></figure><figure><img src="/images/image-20240309114453958.png"alt="image-20240309114453958" /><figcaption aria-hidden="true">image-20240309114453958</figcaption></figure><h3id="那我能不能把钩子放到.deploy_git的.git里这样就能hexo-g--d-的时候直接执行钩子了">那我能不能把钩子放到.deploy_git的.git里，这样就能hexog -d 的时候直接执行钩子了</h3><p>理论上，你可以将钩子脚本放在 <code>.deploy_git/.git/hooks</code>里面。因为这个 <code>.git</code>目录确实是一个git仓库，所以它应该能认可钩子脚本。但这样做有一些需要考虑的地方：</p><ol type="1"><li><strong>Hexo 工作流程</strong>：通常，<code>.deploy_git</code>仓库用于存放生成的静态文件，而不是源文件。如果你的钩子脚本主要是为了处理源文件（比如修改Markdown文件中的图片路径），那么它应该在源文件的git 仓库中被触发执行。</li><li><strong>自动化程度</strong>：把钩子放在 <code>.deploy_git</code>中确实可以在执行 <code>hexo deploy</code>时自动处理静态文件。但如果你的钩子脚本是为了更新本地的源Markdown文件的图片路径，那么这个静态文件是由源文件生成的，所以应该在更新源文件后、生成静态文件之前就处理好。</li><li><strong>维护性</strong>：<code>.deploy_git</code>目录通常不会提交到远程源码仓库，因为它的内容会在你运行<code>hexo clean</code>命令或者重新生成网站时被删除或覆盖。这意味着，如果你将钩子脚本放在<code>.deploy_git/.git/hooks</code> 中，当 <code>.deploy_git</code>目录被删除或重新生成时，你可能会丢失这个钩子脚本。</li></ol><p>总结来说，虽然理论上可以将钩子放在<code>.deploy_git/.git/hooks</code> 中使其在执行 <code>hexo g -d</code>时自动执行，但这样做并不是实践中常见的或推荐的工作流程。通常，我们会在源码仓库中处理这些任务，以确保源码的版本控制和钩子脚本可以一起正常工作。如果你确实需要自动化此过程，可能还是需要一个在源码阶段就能够触发的自定义的脚本或命令集。</p><h3id="以下是将图片移动和替换绝对路径为相对路径的功能合并到一个脚本中的代码">以下是将图片移动和替换绝对路径为相对路径的功能合并到一个脚本中的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> shutil<br><br># 设置目标目录<br>target_directory = <span class="hljs-string">&#x27;E:\\BLOG\\source\\images&#x27;</span><br><br># 配置你的Markdown文件的路径<br>markdown_directory = <span class="hljs-string">&#x27;E:\\BLOG\\source\\_posts&#x27;</span><br># 配置存放图片的文件夹名称，相对于markdown_directory<br>images_directory = <span class="hljs-string">&#x27;images&#x27;</span><br><br><br># 替换绝对路径为相对路径的函数<br>def <span class="hljs-built_in">replace_image_path</span>(file_path, image_dir):<br>    # 建立一个正则表达式模式匹配Markdown图片链接<br>    regex = r<span class="hljs-number">&#x27;</span>!\[.*?\]\((.*?)\)&#x27;<br><br>    # 读取Markdown文件内容<br>    with <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) as file:<br>        content = file.<span class="hljs-built_in">read</span>()<br><br>    # 使用正则表达式匹配并替换路径<br>    new_content = content<br>    matches = re.<span class="hljs-built_in">findall</span>(regex, content)<br>    <span class="hljs-keyword">for</span> match in matches:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> match.<span class="hljs-built_in">startswith</span>(<span class="hljs-string">&#x27;http&#x27;</span>):  # 只替换本地文件路径<br>            new_image_path = os.path.<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;/&#x27;</span>, image_dir, os.path.<span class="hljs-built_in">basename</span>(match)).<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>)<br>            new_content = new_content.<span class="hljs-built_in">replace</span>(match, new_image_path)<br><br>    # 写回新的内容到文件<br>    with <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) as file:<br>        file.<span class="hljs-built_in">write</span>(new_content)<br><br><br># 写一个函数来处理文件的移动，并替换Markdown文件中图片的引用<br>def <span class="hljs-built_in">process_markdown_files</span>(md_directory, target_dir):<br>    <span class="hljs-keyword">for</span> root, dirs, files in os.<span class="hljs-built_in">walk</span>(md_directory):<br>        <span class="hljs-keyword">for</span> file in files:<br>            <span class="hljs-keyword">if</span> file.<span class="hljs-built_in">lower</span>().<span class="hljs-built_in">endswith</span>(<span class="hljs-string">&#x27;.md&#x27;</span>):<br>                full_path = os.path.<span class="hljs-built_in">join</span>(root, file)<br>                <span class="hljs-built_in">move_images</span>(full_path, target_dir)<br>                <span class="hljs-built_in">replace_image_path</span>(full_path, images_directory)<br><br><br># 处理文件移动的函数<br>def <span class="hljs-built_in">move_images</span>(md_file_path, target_dir):<br>    with <span class="hljs-built_in">open</span>(md_file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) as file:<br>        content = file.<span class="hljs-built_in">read</span>()<br><br>    # 正则表达式查找所有 Markdown 图片链接<br>    image_paths = re.<span class="hljs-built_in">findall</span>(r<span class="hljs-number">&#x27;</span>!\[.*?\]\((.*?)\)<span class="hljs-string">&#x27;, content)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    if not image_paths:</span><br><span class="hljs-string">        print(f&quot;No images found in &#123;md_file_path&#125;&quot;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    for image_path in image_paths:</span><br><span class="hljs-string">        # 检查是否是绝对路径</span><br><span class="hljs-string">        if os.path.isabs(image_path):</span><br><span class="hljs-string">            # 获取图片名和目标路径</span><br><span class="hljs-string">            image_name = os.path.basename(image_path)</span><br><span class="hljs-string">            destination = os.path.join(target_dir, image_name)</span><br><span class="hljs-string"></span><br><span class="hljs-string">            # 显示正在处理的图片</span><br><span class="hljs-string">            print(f&quot;Processing image: &#123;image_name&#125;&quot;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">            # 如果目标路径下没有这个文件再进行移动</span><br><span class="hljs-string">            if not os.path.exists(destination):</span><br><span class="hljs-string">                # 尝试移动图片，如果原始图片路径不存在则会抛出异常</span><br><span class="hljs-string">                try:</span><br><span class="hljs-string">                    shutil.move(image_path, destination)</span><br><span class="hljs-string">                    print(f&#x27;</span>Moved image &#123;image_name&#125; to &#123;target_dir&#125;<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">                except FileNotFoundError:</span><br><span class="hljs-string">                    print(f&#x27;</span>Image <span class="hljs-keyword">not</span> found at &#123;image_path&#125;, skipped moving<span class="hljs-number">&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(f<span class="hljs-number">&#x27;</span>Image &#123;image_name&#125; already exists in target directory; no action taken<span class="hljs-number">&#x27;</span>)<br><br><br># 开始处理Markdown文件和图片<br><span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;Processing Markdown files and images in &#123;markdown_directory&#125;&quot;</span>)<br><span class="hljs-built_in">process_markdown_files</span>(markdown_directory, target_directory)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;All Markdown file image paths and images have been processed.&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DAY3日寄-苍穹外卖02-力扣刷题</title>
    <link href="/2024/03/09/DAY3/"/>
    <url>/2024/03/09/DAY3/</url>
    
    <content type="html"><![CDATA[<hr /><h3id="当你想要重新学习并使用-c-来刷力扣leetcode时以下是一些建议和步骤可以帮助你">当你想要重新学习并使用C++ 来刷力扣（LeetCode）时，以下是一些建议和步骤可以帮助你：</h3><p>复习基础知识：</p><ul><li><strong>复习语法</strong>：回顾 C++的基本语法，如变量、数据类型、运算符、流程控制等。</li><li><strong>STL（标准模板库）</strong>：学习 C++标准库中的常用数据结构和算法，如向量（vector）、映射（map）、队列（queue）、堆栈（stack）等。</li></ul><p>相等的时候先放nums1的元素</p><h3 id="vector自动变化大小">vector自动变化大小</h3><ol type="1"><li><strong>获取数组大小</strong>：使用 <code>size()</code>成员函数来获取数组的大小（元素个数）。例如，要获取数组的大小，可以使用<code>nums1.size()</code>。</li><li><strong>插入元素</strong>：使用 <code>push_back()</code>成员函数将元素添加到数组的末尾。例如，要将新元素 <code>5</code>插入到数组末尾，可以使用 <code>nums1.push_back(5)</code>。</li><li><strong>删除元素</strong>：使用 <code>pop_back()</code>成员函数删除数组的最后一个元素。例如，要删除数组的最后一个元素，可以使用<code>nums1.pop_back()</code>。</li><li><strong>遍历数组</strong>：使用循环结构（如 <code>for</code>循环）和索引操作符 <code>[]</code>来遍历数组中的所有元素。例如，可以使用以下代码遍历并打印数组中的所有元素：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    cout &lt;&lt; nums1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sort</code>函数接受两个迭代器作为参数，表示排序范围的起始和结束位置。如果要进行降序排序，可以使用<code>sort(myVector.rbegin(), myVector.rend())</code>，其中<code>rbegin()</code>和<code>rend()</code>表示逆序的起始和结束位置。</p><p>sort(myVector.begin(), myVector.end()); <em>// 默认升序排序</em></p><h3 id="合并两个有序数组">合并两个有序数组</h3><p>先将数组 nums2放进数组 nums1的尾部，然后直接对整个数组进行排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            nums1[m+i]=nums2[i];<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(),nums1.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 C++ 中，你不能直接通过 <code>int i = j = p = 0;</code>这样的方式来同时初始化多个变量，因为 C++ 不支持链式赋值。</p><p>还是一天做一道题吧...</p><h3 id="ctrl鼠标左键跳入类">ctrl+鼠标左键跳入类</h3><h3 id="selectselect-from-employee-where-username-username"><spanclass="citation" data-cites="Select">@Select</span>("select * fromemployee where username = #{username}")</h3><p>看起来你提供的代码片段类似于MyBatis中的SQL查询语句。这段代码使用了MyBatis的注解<code>@Select</code>，并包含了一个查询语句<code>select * from employee where username = #&#123;username&#125;</code>。</p><p>在这个查询语句中，<code>#&#123;username&#125;</code>是一个参数占位符，表示在实际执行查询时会替换为具体的<code>username</code>的值。这种方式可以有效防止SQL注入攻击。</p><p>需要注意的是，<code>@Select</code>注解通常用于在MyBatis的Mapper接口方法上，用于指定对应的SQL查询语句。在实际使用中，你需要确保传入正确的参数值来执行这个查询。</p><h3id="mybatis会自动处理参数的转义和过滤以防止sql注入攻击">MyBatis会自动处理参数的转义和过滤，以防止SQL注入攻击。</h3><p>它使用预编译语句（PreparedStatement）或命名参数来处理参数，并在执行查询之前自动进行参数值的转义。</p><p>当你在MyBatis的注解语句中使用<code>#&#123;&#125;</code>占位符时，MyBatis会自动将参数进行安全处理。它会确保参数值不会被误解为SQL代码的一部分，并且会对特殊字符进行转义，从而防止注入攻击。</p><p>因此，当使用MyBatis进行数据库查询时，你无需手动编写过滤或转义逻辑来防止SQL注入攻击。但是，仍然需要保证输入的参数值都是可信的，以避免其他类型的安全漏洞。</p><p>在Windows环境下，文件默认是可执行的，所以你不需要像在Unix-like系统中那样修改文件权限。只需确保你的<code>pre-commit</code>钩子脚本的内容是正确的，并且它放置在<code>.git/hooks</code>目录下。</p><h3 id="hexo-clean之后我所有放在source里的图片是不是都会被删除">hexoclean之后，我所有放在source里的图片是不是都会被删除</h3><p>使用<code>hexo clean</code>命令的作用主要是清除Hexo生成的缓存（<code>.db</code>文件）和已生成的静态文件（通常是<code>public</code>目录下的内容）。这个命令不会删除<code>source</code>目录下的内容，包括您放置在那里的图片。</p><p>在Hexo项目结构中，<code>source</code>目录是用来存放所有资源文件的地方，包括Markdown文件、图片以及其它静态文件等。在运行<code>hexo generate</code>或<code>hexo server</code>命令时，Hexo会从<code>source</code>目录读取文件，并生成相应的静态网页放到<code>public</code>目录。</p><p>因此，您可以放心使用<code>hexo clean</code>，它不会影响到您在<code>source</code>中储存的资源文件。不过，无论何时进行文件操作，定期备份仍然是一个好习惯，以防万一出现意外情况。</p><p>https://mp.weixin.qq.com/s/Z36m4_W5Q_5h-bg2_d9yOA</p>]]></content>
    
    
    <categories>
      
      <category>日寄</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DAY2日寄-苍穹外卖01-毕设电子</title>
    <link href="/2024/03/08/DAY2/"/>
    <url>/2024/03/08/DAY2/</url>
    
    <content type="html"><![CDATA[<figure><img src="/images/image-20240308094713778.png"alt="image-20240308094713778" /><figcaption aria-hidden="true">image-20240308094713778</figcaption></figure><figure><img src="/images/image-20240308094749852.png"alt="image-20240308094749852" /><figcaption aria-hidden="true">image-20240308094749852</figcaption></figure><figure><img src="/images/image-20240308095429320.png"alt="image-20240308095429320" /><figcaption aria-hidden="true">image-20240308095429320</figcaption></figure><figure><img src="/images/image-20240308100445990.png"alt="image-20240308100445990" /><figcaption aria-hidden="true">image-20240308100445990</figcaption></figure><figure><img src="/images/image-20240308102810152.png"alt="image-20240308102810152" /><figcaption aria-hidden="true">image-20240308102810152</figcaption></figure><figure><img src="/images/image-20240308103740063.png"alt="image-20240308103740063" /><figcaption aria-hidden="true">image-20240308103740063</figcaption></figure><p>在acwing花了两千块钱了</p><figure><img src="/images/image-20240308104638739.png"alt="image-20240308104638739" /><figcaption aria-hidden="true">image-20240308104638739</figcaption></figure><p>双击nginx项目的nginx.exe就能启动，路径不能带中文，localhost，端口默认80不用输入</p><h3id="万用表交流测的是峰峰所以电压会达到六百多伏">万用表交流测的是峰峰，所以电压会达到六百多伏</h3><p><ahref="https://www.bilibili.com/video/BV1Mc411o7gN?p=3&amp;vd_source=e404ad14246992bcc3e4ac52a33df8ed">（基础）基本电路知识_哔哩哔哩_bilibili</a></p><p>DTO data transfer object 数据传输对象，各层传输数据</p><p>VO view object 视图对象，前端展示</p><p>POJO 只有属性和getter和setter</p><p>Entity 实体，对应数据库表</p><h3 id="idea等连接github的代理设置">idea等连接github的代理设置</h3><p>对windows用户来说，只需要在命令行执行如下命令即可。这样就可以通过代理访问github了。</p><p>如果是http代理：</p><p>git config --global http.https://github.com.proxyhttp://127.0.0.1:7890</p><p>//如果是sock代理 git config --global http.https://github.com.proxysocks5://127.0.0.1:1080</p><figure><img src="/images/image-20240308161233439.png"alt="image-20240308161233439" /><figcaption aria-hidden="true">image-20240308161233439</figcaption></figure><p><ahref="https://blog.csdn.net/weixin_45959563/article/details/120295759">idea报错解决办法：Errorexecuting Maven. The specified user settings file does not exist:C:.m2-CSDN博客</a></p><figure><img src="/images/image-20240308161746203.png"alt="image-20240308161746203" /><figcaption aria-hidden="true">image-20240308161746203</figcaption></figure><figure><img src="/images/image-20240308162617063.png"alt="image-20240308162615780" /><figcaption aria-hidden="true">image-20240308162615780</figcaption></figure><p>application.yml里改了端口号，8080和8090都在被占用，但netstat发现没被占用，最后改成42220就行了奇怪</p><p>mysql命令</p><figure><img src="/images/image-20240308163604573.png"alt="image-20240308163604573" /><figcaption aria-hidden="true">image-20240308163604573</figcaption></figure><p>ERROR 1045 (28000): Access denied for user 'root'@'localhost' (usingpassword: YES)</p><figure><img src="/images/image-20240308164001405.png"alt="image-20240308164001405" /><figcaption aria-hidden="true">image-20240308164001405</figcaption></figure><p>要用管理员shell运行mysql的启动停止命令，mysql的名称是mysql80，不分大小写</p><h3 id="mysql服务的启动和停止">mysql服务的启动和停止</h3><p>net start mysql80</p><p>记得有80（在win+r的service.msc里看的服务名）</p><p><ahref="https://blog.csdn.net/weixin_40873693/article/details/113056113">执行scquery mysql，sc delete mysql没有反应_sc deletemysql80没有反应-CSDN博客</a></p><p><ahref="https://blog.csdn.net/qq_42785280/article/details/97255637">MySQL：netstart MySQL80：发生系统错误 5。拒绝访问。_net start mysql80 发生系统错误5。 拒绝访问。-CSDN博客</a></p><p><ahref="https://blog.csdn.net/hkdhkdhkd/article/details/121158926">Mysql忘记登录密码的解决步骤（完整步骤）_mysql密码忘了怎么办-CSDN博客</a></p><p><ahref="https://blog.csdn.net/weixin_40845165/article/details/100943054">ERROR1054 (42S22): Unknown column 'password' in 'field list'-CSDN博客</a></p><figure><img src="/images/image-20240303092609821.png"alt="image-20240303092609821" /><figcaption aria-hidden="true">image-20240303092609821</figcaption></figure><figure><img src="/images/image-20240303092857419.png"alt="image-20240303092857419" /><figcaption aria-hidden="true">image-20240303092857419</figcaption></figure><p>重装了一遍mysql，密码改成了0000</p><h3id="我在idea里改了几个参数再重新运行项目的时候还需要重新maven构建吗">我在idea里改了几个参数，再重新运行项目的时候还需要重新maven构建吗</h3><p>一般来说，如果你在IDEA中改变了项目中的参数，并且这些参数是在构建过程中被使用到的（例如pom.xml中的配置参数），那么重新进行Maven构建可能是必要的，以确保这些变化被正确应用。如果是改变了代码中的参数，而这些参数不影响项目的依赖关系或构建过程，通常仅需要重新编译改动的部分即可。不过进行完整构建可以确保一切都是最新的，避免某些情况下因为环境的不同步导致的问题。</p><h3 id="启动流程">启动流程：</h3><p>1前端nginx文件夹双击</p><p>2 mysql启动（mysql -u root -p）</p><p>3 idea，skyserver，skyapplication类启动</p><p>注意点：</p><p>application-dev.yml改mysql的密码的时候，纯数字要加单引号</p><h3id="nginx配置文件里的这一段中weight是干什么用的">nginx配置文件里的这一段中，weight是干什么用的</h3><p>upstream webservers{ server 127.0.0.1:8080 weight=90 ; #server127.0.0.1:8088 weight=10 ; }</p><p>在Nginx配置文件的<code>upstream</code>模块中，<code>weight</code>参数用于定义负载均衡时各服务器的权重比例。在你这个<code>upstream</code>块中，使用了<code>weight</code>参数来分配请求到不同服务器的相对比例。</p><ul><li><code>server 127.0.0.1:8080 weight=90;</code>表明第一个服务器（在这里是本机的8080端口上的服务器）的权重是90。</li><li><code>#server 127.0.0.1:8088 weight=10;</code>这一行已被注释掉，但如果取消注释，它将表明第二个服务器（在这里是本机的8088端口上的服务器）的权重是10。</li></ul><p>当有一个请求到达<code>upstream</code>定义的服务器组时，Nginx会按照权重来决定将请求发送到哪个服务器。在这个例子中，如果第二行没有被注释掉，那么理论上每有100个请求，大约90个会被发送到端口8080上的服务器，而大约10个请求会被发送到端口8088的服务器。</p><p>使用权重可以使得流量分配更加灵活，特别是当服务器的处理能力不相同时，可以通过调整权重来分配更多的请求到性能更强的服务器上。</p><h3 id="断点调试">断点调试</h3><figure><img src="/images/image-20240308183647122.png"alt="image-20240308183647122" /><figcaption aria-hidden="true">image-20240308183647122</figcaption></figure><p>ctrl+alt+B，跳转到方法.</p><figure><img src="/images/image-20240308184049708.png"alt="image-20240308184049708" /><figcaption aria-hidden="true">image-20240308184049708</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>日寄</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DAY1日寄-主修毕设电路原理图绘制</title>
    <link href="/2024/03/08/DAY1/"/>
    <url>/2024/03/08/DAY1/</url>
    
    <content type="html"><![CDATA[<h2 id="day1日寄-主修毕设电路原理图绘制">DAY1日寄主修毕设电路原理图绘制</h2><p>常见暖气片漏水部位：</p><p>由于工艺的原因，暖气片片头与柱体是焊接在一起的，并不是一个整体，焊点处最容易被腐蚀。</p><p>毕设要做基于esp8266的暖气片漏水检测系统，要自己画电路板，温湿度检测，要知道暖气片口径的尺寸 内径为20mm，外径约为25mm</p><p>流量传感器的数据需要有自学习的过程，一段时间后应该有最优的数值，esp8266传到手机端的报警信号，手机端可发送控制命令关闭暖气的阀门，理论上不是很难，但细节要详细设计，包括pcb板都要设计好。</p><p>stm32最小系统板？√</p><p>esp8266√</p><p>oled屏幕√</p><p>mos管控制电磁阀√</p><p>有源蜂鸣器√</p><p>流量传感器（已经下单）</p><p>AC交流，DC直流</p><p>S8050三极管驱动继电器，继电器控制电磁阀</p><p>0欧姆电阻？</p><figure><img src="/images/image-20240307112316088.png"alt="image-20240307112316088" /><figcaption aria-hidden="true">image-20240307112316088</figcaption></figure><figure><img src="/images/image-20240307180836061.png"alt="image-20240307180836061" /><figcaption aria-hidden="true">image-20240307180836061</figcaption></figure><p>我现在在画基于stm32的pcb板，我先从网上下载了stm32最小系统板的原理图，再自己添加上esp8266等模块，但是我有个问题，就是我下载的stm32最小系统板的原理图里，stm32的可用引脚都通过排针外扩了，我如果把已经外扩了的引脚也连到我添加的esp8266模块上会发生什么，这么做是对的吗，我能在外扩的同时也连接模块吗</p><p>没问题的，其实这样的设计在PCB板设计中很常见。STM32的可用引脚通过排针外扩，是为了能够便捷地连接到其他电路或测试设备。至于你想要将这些引脚同时连到ESP8266模块上，完全是可以的，前提是你需要确保以下几点：</p><ol type="1"><li>电气连接正确：确保STM32的引脚与ESP8266模块的对应引脚电气特性兼容，没有冲突。比如说，不要把供电引脚错误地连接到地引脚或信号引脚。</li><li>信号干扰问题：当一个引脚连接多个模块时，可能会引入信号干扰。你需要设计合适的走线和地平面,并在必要时添加适当的滤波和隔离元件。</li><li>I/O负载：确保STM32的I/O引脚没有超出其承受的驱动能力。每个I/O引脚都能提供一定的电流，你要检查所有连接到该引脚的模块总共需要的电流是否超出了STM32引脚的最大输出电流。</li><li>软件管理：在软件层面，你需要正确地配置STM32的I/O引脚，避免在程序中造成引脚状态的冲突。</li></ol><p>只要你能够处理好上述提到的几个方面，你就可以在外扩的同时也连接模块。当然，进行这样的设计之前，最好还是好好规划一下，确保整个系统的稳定性和可靠性。开工前做好设计和规划，事半功倍喔</p><p>当你将STM32的一个单独引脚同时连接到外扩引脚和另一个模块（比如ESP8266）时，在软件编程方面需要考虑到以下几点：</p><ol type="1"><li><strong>引脚功能冲突</strong>：确保在同一时刻，这个引脚不会被外扩接口和ESP8266同时要求执行不同的功能。你需要设计你的程序逻辑来避免这种冲突，比如通过状态机来管理这个引脚的状态。</li><li><strong>引脚方向设置</strong>：程序中需要设置GPIO的输入/输出方向。如果引脚被配置为输出，STM32将能够向ESP8266发送信号；如果配置为输入，STM32将能够接受来自ESP8266的信号。如果同一时刻既想读信号也想写信号，就需要编写控制代码来临时切换引脚状态。</li><li><strong>互斥访问</strong>：如果某一时刻只允许外扩引脚或者ESP8266中的一个与STM32的引脚进行通信，你需要确保程序中通过某种互斥机制来管理这种通信的访问。可以通过软件标志位来确定哪个模块可以使用该引脚。</li></ol><p>举个例子:假设有一个引脚PA0，你同时连接到了外扩接口和ESP8266。那么你的程序可能会这样控制：</p><p>c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 检测ESP8266模块是否需要通信</span><br><span class="hljs-keyword">if</span> (ESP8266_needs_communication) &#123;<br>    <span class="hljs-comment">// 配置PA0为通信所需的模式</span><br>    GPIO_InitStruct.Pin = GPIO_PIN_0;<br>    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; <span class="hljs-comment">// 假设为特定的替代功能</span><br>    GPIO_InitStruct.Pull = GPIO_NOPULL;<br>    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);<br>    <br>    <span class="hljs-comment">// 与ESP8266模块进行数据交换</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 如果外扩接口需要使用PA0</span><br><span class="hljs-keyword">if</span> (extension_needs_communication) &#123;<br>    <span class="hljs-comment">// 配置PA0为外扩接口所需的模式</span><br>    GPIO_InitStruct.Pin = GPIO_PIN_0;<br>    GPIO_InitStruct.Mode = GPIO_MODE_INPUT; <span class="hljs-comment">// 假设外扩为输入模式</span><br>    GPIO_InitStruct.Pull = GPIO_PULLUP;<br>    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);<br><br>    <span class="hljs-comment">// 与外扩接口进行数据交换</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在实际应用中，你可能还需要加入一些延时或者中断，以确保STM32可以正确地处理来自不同源的信号。还有很多优雅的处理方式，上面的代码只是一个简单的示例。</p><p>记住，当你设计这样的复用引脚时，一定要确保不会引起电气层面的冲突，并且确保在任何时刻引脚状态的改变都是在你的控制之下，不会不经意间发生。</p><figure><img src="/images/image-20240307185323901.png"alt="image-20240307185323901" /><figcaption aria-hidden="true">image-20240307185323901</figcaption></figure><figure><img src="/images/image-20240307185338961.png"alt="image-20240307185338961" /><figcaption aria-hidden="true">image-20240307185338961</figcaption></figure><p>当然可以，ESP8266-12F是一个非常受欢迎的WiFi模块，具有紧凑的尺寸和低功耗，非常适合物联网(IoT)项目。以下是常见的几个原理图连接点的解释：</p><ol type="1"><li><strong>天线</strong>:ESP8266-12F包含一个PCB板天线，且通常不需要外加天线。这是连接到无线网络的关键部分。</li><li><strong>电源</strong>：ESP8266-12F需要一个稳定的3.3V电源，供电电压不能高于3.6V。可能还会看到一个电源旁有去耦电容以稳定电源，并避免因为供电波动造成运行时的不稳定。</li><li><strong>GPIO</strong>：这些引脚为通用输入输出端口，用来连接传感器、执行器或其他模块。</li><li><strong>串行通信引脚（RX/TX）</strong>：这些用于与ESP8266交流数据，如用于编程固件或和其他设备的通信。</li><li><strong>CH_PD(ChipEnable)</strong>引脚需要连接到VCC来激活芯片；</li><li><strong>RESET</strong>：复位引脚可用于重启模块。</li><li><strong>GPIO15, GPIO0,GPIO2</strong>和<strong>EN（Enable）</strong>引脚通常会有特定的上拉或下拉电阻，以确保ESP8266在启动时能进入正确的启动模式。比如：<ul><li><strong>GPIO15</strong>需要接地（带下拉电阻）。</li><li><strong>GPIO0</strong>决定了模块是进入编程模式还是正常启动，通常通过上拉来正常启动。</li><li><strong>GPIO2</strong>也需要上拉。</li></ul></li><li><strong>去耦电容</strong>：在电源线和地之间接去耦电容非常重要，这有助于滤除电源中的噪声，使模块运行更加稳定。</li></ol><p>每个电路设计都有其特定目的和电气特性的考量。设计者在手册或数据表的指导下进行设计，以确保模块稳定工作并遵守电气规范。如果你有特定的设计方面的问题或者需要详细的电路解释，提供更多的上下文将有助于给出更精确的解答。希望这些信息对你的项目有帮助！🛠️📡</p><h3id="要将-esp8266-12f-wifi-模块与-stm32f103c8t6-微控制器连接并控制它你可以按照以下简单步骤操作">要将ESP8266-12F WiFi 模块与 STM32F103C8T6微控制器连接并控制它，你可以按照以下简单步骤操作：</h3><ol type="1"><li><strong>供电</strong>：<ul><li>ESP8266 需要 3.3V 的电源，这意味着你可以直接从 STM32 板上的 3.3V引脚供电给 ESP8266。</li><li>确保你的电源能够提供足够的电流，因为 ESP8266在启动或通信时可能会短暂消耗较高功率。</li></ul></li><li><strong>串行通信</strong>：<ul><li>将 ESP8266 的 TX（发送）引脚连接到 STM32F103C8T6 的某个 UART接收（RX）引脚上。</li><li>将 ESP8266 的 RX（接收）引脚连接到 STM32F103C8T6 的某个 UART发送（TX）引脚上。</li><li>选择合适的 GPIO 引脚分配给 UART 接口，并在 STM32软件中适当配置。</li></ul></li><li><strong>编程与控制</strong>：<ul><li>使用 STM32 的 UART 接口，通过发送 AT 指令来控制ESP8266。这些指令用于设置网络连接、发送数据等。</li><li>根据你的需要，可能要编写或使用一个串口库来管理 UART 通讯。</li></ul></li><li><strong>GPIO 互连</strong>（可选）：<ul><li>如果你需要更精细的控制，如重置 ESP8266 或监控其状态，你也可以将ESP8266 的 GPIO 引脚（如 CH_PD 或 RESET）连接到 STM32 的 GPIO引脚，并通过软件控制它们。</li></ul></li><li><strong>软件配置</strong>：<ul><li>在 STM32 中设置 UART 接口的波特率，确保它与 ESP8266的设置相匹配。</li><li>实现或使用一个库来发送 AT 指令并解析响应。</li><li>创建一个循环来维护 WiFi 连接，处理网络通信任务。</li></ul></li></ol><p>下面是一个示例连接图：</p><table><thead><tr class="header"><th>ESP8266</th><th>STM32F103C8T6</th></tr></thead><tbody><tr class="odd"><td>VCC</td><td>3.3V</td></tr><tr class="even"><td>GND</td><td>GND</td></tr><tr class="odd"><td>TX</td><td>PA10 (RX)</td></tr><tr class="even"><td>RX</td><td>PA9 (TX)</td></tr><tr class="odd"><td>CH_PD</td><td>3.3V (通常与 VCC 连接)</td></tr><tr class="even"><td>RESET</td><td>(可选连接至 STM32 GPIO)</td></tr></tbody></table><p>在编写代码来控制 ESP8266 之前，请确保你已经通过 USB-to-Serial转换器或类似的东西更新了 ESP8266 的固件，并且能够理解和使用 AT指令集。</p><p>请牢记：</p><ul><li>在连接之前，请双检查所有的引脚配置，以避免任何硬件损坏。</li><li>焊接 ESP8266-12F 模块通常比较困难，因为它是一个带有金属盖的小型 SMD模块。小心操作，以免烧坏模块或相关的电路。</li></ul><h3id="要通过i2c接口连接stm32f103c8t6以下简称stm32与hs96l03-oled显示模块以下简称oled您需要按照以下步骤操作">要通过I2C接口连接STM32F103C8T6（以下简称STM32）与HS96L03OLED显示模块（以下简称OLED），您需要按照以下步骤操作：</h3><ol type="1"><li><strong>电源连接</strong>：<ul><li>将STM32的VCC引脚连接到OLED模块的VCC，提供所需电压（通常为3.3V或5V，需根据规格书确定）。</li><li>将STM32的GND引脚连接到OLED模块的GND，形成共同的地线。</li></ul></li><li><strong>I2C数据线连接</strong>：<ul><li>将STM32的I2C_SDA引脚连接到OLED模块的SDA引脚。</li><li>将STM32的I2C_SCL引脚连接到OLED模块的SCL引脚。</li></ul></li><li><strong>外接上拉电阻</strong>：<ul><li>在SDA和SCL线路上，分别外接上拉电阻到VCC。通常电阻值可以选择在4.7kΩ到10kΩ之间，具体值需要根据系统的I2C总线长度以及所用OLED模块的电气特性来决定。</li></ul></li><li><strong>配置STM32</strong>：<ul><li>在STM32的固件中配置I2C接口，包括初始化I2C时钟速率、地址模式和所使用的I2C端口等。</li><li>如果OLED模块有特定的初始化序列，也需要按照规格书中的要求，在STM32固件中加入相应的初始化代码。</li></ul></li><li><strong>编写显示代码</strong>：<ul><li>开发相应的软件来驱动OLED，并实现所需的显示功能，比如显示文本、图像等。</li></ul></li><li><strong>实际测试</strong>：<ul><li>在接线完成后，上传固件并对连接进行测试，以确保I2C通信正常工作且OLED可以正确显示。</li></ul></li></ol><p>在进行连接前，请确保参考STM32以及OLED的规格书来获取精确的接线信息及电气参数，防止因误接线而损坏设备。此外，在连接OLED之前，请先通过STM32的数据手册验证其的I2C引脚位置，因为不同的STM32模型其I2C引脚配置可能会有所不同。如果一切按照上述步骤进行并且规格都符合要求，那么I2C接口的连接应该就能够实现功能。</p>]]></content>
    
    
    <categories>
      
      <category>日寄</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24考研的具体经验反思</title>
    <link href="/2024/03/02/24%E8%80%83%E7%A0%94%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%8F%E9%AA%8C%E5%8F%8D%E6%80%9D/"/>
    <url>/2024/03/02/24%E8%80%83%E7%A0%94%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%8F%E9%AA%8C%E5%8F%8D%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="考研的具体经验反思">24考研的具体经验反思</h1><p>（未完成）</p><hr /><p>我觉得github上有个仓库极其的好，叫《考研：有手就行》</p><p>这位大哥是二战的，22年分数一般，但23年上岸上交计算机，水平真不是一般人，</p><blockquote><ul><li>第一次的初试分数是79 + 72 + 93 + 86 = 330（11408），未进复试。</li><li>第二次的初试分数是80 + 75 + 137 + 122 =414（11408），复试分数是180分（总分200）。</li></ul></blockquote><p>我今年是64 + 79 + 97 + 100 = 340（11408），</p><p>鉴于我这北京和他那上海都挺旱的，只能说我俩一战水平差不多。</p><hr /><p>他给出了无比具体且可量化的方法，</p><p>趁现在还早，你如果严格按照他的方式来，是真的可以考个巨无敌高的分数。</p><p>（额也说不定，万一明年题更难了，超纲题更多了，这种情况看谁都没用）</p><p>我当时看到的时候已经晚了。</p><hr /><p>记得这个库还是后台一粉丝介绍给我的，说我和那个大佬理念很相似，</p><p>经过这一切之后再想起这个评价，真是太讽刺了。</p><hr /><p>我其实不想由果索因，因为会额外否定很多东西。</p><p>但没有结果的时候，又会不自觉美化自己的行为。</p><hr /><p>个人情况：</p><p>山东高考，末流985，计算机本科，一战北京11408，笨拙的努力型选手。</p><hr /><h2 id="政治">1 政治</h2><p>客观39，主观25，总分64.</p><p>简单来说，还是别花时间学政治了。</p><hr /><h3 id="选择">1.1 选择</h3><p>我后期买了那个喵刷政治的微信小程序，也买了苍盾政治的小程序，</p><p>比较之后用喵刷，UI简洁舒适，能归类错题生成pdf打印纸质版，</p><p>最重要的是能长按排除选项，对于选择题来说很有用。</p><p>对了，我提到的都不是广，没有人会找我这种没粉丝的公众号投广告。</p><hr /><p>然后用喵刷刷了几乎所有的模拟卷的选择；肖八肖四选择题二刷三刷、纸质版刷完小程序刷；错题归档，打印纸质版继续二刷三刷。</p><p>背腿姐手册，背b站帕拉迪宇的一页纸，用政治带背下饭，</p><p>最后选择39，错仨单选，四多选。</p><p>挺烂，我记得今年出来之后很多人说政治选择简单。</p><hr /><p>政治选择方面应该很少人能超过我花费的时间。</p><p>你看，这可怜的投入产出比，（笑）。</p><p>不过我记得肖八刚出来的时候我第一套选择19分，大家平均也在一二十分左右，</p><p>该看的还是得看看，才能上40，</p><p>我意思就是该刷的刷，别刷多了。</p><p>十二月只刷肖八肖四吧各位，刷多了也没用。</p><p>反正大家水平都差不多之后，主要还是看运气。</p><hr /><p>平常互联网键政的各位，尤其是魔怔人，</p><p>我建议你们前期也不用买核心考案听徐涛的课了，很多概念你们都懂，</p><p>不懂的东西到十一二月的时候对着背诵手册细品一下也就明白了，很多都是你们平常唠的东西。</p><hr /><h3 id="大题">1.2 大题</h3><p>我这可怜的25分，我分析的是，</p><ul><li>京区主观狠压分</li><li>字体巨无敌烂</li><li>套张修齐模板抄材料少</li></ul><hr /><p>我现在挺后悔的，每天挂嘴边的就是京区把我害惨了，</p><p>放别的水区政英高二十分，调剂得多好调，</p><p>这就是当时不考虑退路的下场。</p><hr /><p>字体巨无敌烂这一点我也没想到，我没想到威海职业学院那几天那么冷，</p><p>前一天刚下完持续几周的雪，后一天就开始考试，化雪的同时考场还是没暖气的阶梯教室，</p><hr /><p>备考的时候要不还是找找适合你考场的温度吧，</p><p>像我，所有备考的时间为了不让身体状态影响我，都选择的是冬暖夏凉的图书馆，</p><p>导致我在20℃图书馆里模拟的政治字体间距排版等等一切，在零下的考场上全部失效。</p><hr /><p>买了四五十个暖宝宝，那两天全用完了，到处都贴，只能管前一小时，手还是冻僵握不住笔。</p><p>写的时候很难受，</p><p>我因为背的张修齐，每道题能写上的东西极其的多，我不想放过任何一个得分点，就把每一个答题空都写上了密密麻麻的蝇头小字，最后看我的答题卡，可以算是乌黑一片，</p><p>手冻僵了完全控制不了，同时肾上腺素作用，我边发抖边写字，这种情况下也没办法控制字体。</p><p>最后就是这个结果。</p><hr /><p>最后一点，</p><p>我觉得张修齐老师确实很好，直播点拨的答题思路经常让人恍然大悟，</p><p>娱乐性也强，懂得都懂，</p><p>十页纸也很好用，覆盖考研大题，减少了绝大部分背诵负担。</p><p>考水区的可以放心跟张修齐老师。</p><p>考旱区的话，我建议是肖八肖四也得看看，结合材料，自己组织语言和答分点，简洁清晰的卷面更重要。</p><hr /><p>还是那句话，你到十一二月再开政治完全不迟。</p><hr /><figure><img src="/images/image-20240302191735961.png"alt="image-20240302191735961" /><figcaption aria-hidden="true">image-20240302191735961</figcaption></figure><h2 id="英语">2.英语</h2><p>完型全对，阅读错仨，主观小作文6.5/10，大作文11/20，翻译7/10，只能说难评，京区就这样。</p><hr /><h3 id="客观">2.1 客观</h3><p>四六级裸考均分580，属于英语没那么好，但也不用额外补的水平。</p><p>单词没背完，太多了，红宝书那么一厚本我是真难绷，不背单词显示有六千多个？</p><p>我寻思着光单单在软件上按完就得花我一辈子。</p><hr /><p>后来只在不背单词上随便选了一个只有七八百的考研核心词的词书，</p><p>也没背完，最后剩了二百多个。</p><p>我的经验是还是得三人组队，找俩比较好的朋友，互相监督，不然我根本没时间打开软件。</p><p>当时主要背单词的时间都是在组队的那一个月背的，每天背十五分钟打卡，打完立马关了。</p><hr /><p>真题大概做了不到十套，</p><p>十月份的时候先做的10、11年的，当时完型动辄错11、12个，气笑了，就没再管，因为知道那段年份难。</p><p>后来十一月有空的时候做了几套近几年的选择，觉得阳间了不少，</p><p>完型稳定在两三个，阅读稳定在三四个，</p><p>当时实在是没时间，寻思着既然这水平能用了，就这样得了。</p><p>所以最后考试前那一个月也没做一两套英语，全吃老本。</p><hr /><p>最后证明运气还行，考场上的文章都能看懂，花二十分钟做完了客观题。</p><hr /><h3 id="主观">2.2 主观</h3><hr /><p>大作文用的红果研王晶婷的作文书，实在是很好用，</p><p>像拼图一样，可以选用不同水平的句子拼凑出属于自己的模板，</p><p>但主要还是靠当场发挥。</p><hr /><p>小作文搁十二月份背背那几个信件类型开头结尾的句式就行，</p><p>我感觉考研从我这届开始变得变化莫测了，试图考前压中题目是极其吃力不讨好的事儿，</p><p>中间的部分还不如当场发挥。</p><hr /><p>十一二月开始，大小作文分别模了两三次吧，平常就背背自己攒的模板。</p><hr /><p>翻译没啥说的，感觉无论翻译的再好在北京都会每道题扣0.5。</p><hr /><p>小作文写跑题了，</p><p>人外国人说要做一个ancientscientist的讲座，关于古代中国科学家的讲座，</p><p>按理说应该推荐中国古代的科学家，所以舍友问我写的谁的时候我汗流浃背，</p><p>我看成是面向研究中国古代文明的科学家做中文讲座，</p><p>写让他去bilibili学汉语，让他别担心，中国人都挺友善，你发音不准也不会嘲笑你，</p><p>跑题了还有6.5，可能把批试卷的研究生逗乐了。</p><hr /><p>大作文也挺逗，</p><p>各路老师考前预测，还是如同一成不变的往年，英一还是看图写话类作文，英语二还是图表类作文，</p><p>然后今年发下试卷来，我看了一眼大作文，</p><p>嘿，图片和图表都有，又给我气笑了。</p><p>图片好像是一座公园，游人自得其乐，图表是公园数量逐年上涨。</p><p>凭着仅有的对于图表趋势性描述的记忆简单写了几句。</p><p>后来就是赞颂Party好，government好，人民生活幸福感高，经济稳中向好。</p><p>不然还能说什么呢。</p><hr /><p>总之英语我几乎没花时间，对我来说是性价比爆棚的学科，</p><p>这大概就是那些大佬学数学的感受。</p><hr /><figure><img src="/images/image-20240302202850572.png"alt="image-20240302202850572" /><figcaption aria-hidden="true">image-20240302202850572</figcaption></figure><hr /><h2 id="数学">3 数学</h2><p>这个部分，我都痛苦的不想回忆它。</p><figure><img src="/images/image-20240302212124335.png"alt="image-20240302212124335" /><figcaption aria-hidden="true">image-20240302212124335</figcaption></figure><hr /><p>选择错仨，填空错仨，30分就已经没了。</p><p>极其恐怖。</p><p>我最后还能考97，全靠大题判卷放水。</p><hr /><p>所以那个上交佬在数学篇的一开始就说，</p><blockquote><p>数学是一门方差极大的学科，这个方差既指考生之间的方差，又指考生（发挥）的方差。</p></blockquote><p>我觉得能考到145-150的人，最低也就140，这只是试卷的上限，不是他深厚积累的底线。</p><p>但是在120，110，100分数段的人，完全可以考到90。</p><hr /><p>太痛苦了，是想想就想死的程度。</p><p>如果我备考有100%的时间，</p><p>那么60%的时间都在学数学，</p><p>30%的时间学408四门课，</p><p>8%的时间学政治，</p><p>2%的时间学英语。</p><hr /><p>性价比低到了一个令人咋舌的程度，感觉我学一两个月和我学一年相比，分差也不会超过20。</p><hr /><p>基础和强化全程跟的张宇，</p><p>我觉得没必要一听别人说张宇的课门槛高就退缩，我这种大学高数60分的人都能正常听懂，门槛高又能高到哪儿去呢。</p><p>线代大后期又跟了b站的帕拉迪宇，小铜数学等一系列优秀up主，</p><p>反正他们互相认识也合作过视频，找到一个就可以顺藤摸瓜找到其他人。</p><p>概率论和无穷级数到大后期又跟了一遍方浩。</p><p>记得不要跟考研竞赛凯哥，具体原因自己去找。</p><hr /><p>邂逅遗憾知乎的经验贴害惨了我，让我觉得我也能上，建议看他经验贴之前撒泡尿照照自己。</p><p>rw现在每年炸成这样，有很大一部分原因就是他知乎的经验帖。</p><p>但是他经验帖写的确实好，他推荐的方浩概率论确实不错，</p><p>他自己办的课挺贵的，小班八百多大班四千多，我没听过不做评价。</p><hr /><p>就是方浩的那个书和他的课程不配套真的很烦，我学概率论的时候一大部分时间都在抄他的课上例题，因为题确实有用，</p><p>尤其是张宇的课和他的书配套的极其丝滑，再听方浩的课感觉跟吔了史一样。</p><p>建议别买方浩的书，直接买风中易小生做的方浩做题本自己打印，我也是后来才发现风中易小生的做题本都给整理好了。</p><hr /><p>我虽然考得烂，但张宇老师确实好，教材做得很全，</p><p>上课生动形象，体谅学生，到现在我还记得他讲的狮子王的故事，不过当时听的时候我倍速过去了。</p><p>据说今年数学这样之后各大经验贴都主推张宇老师了，因为张宇老师的全程班基础性好的同时扩展度最高。</p><hr /><p>只能说从此往后，如果卷考研的人继续增多，数学的难度和扩展性也会越来越大，越来越起到选拔人才的作用，</p><p>今年就是最好的例子，狠狠给了我当头一棒，</p><p>没有两把刷子的人好好掂量掂量自己。</p><hr /><p>武老师我是真听不进去，语调太平，感觉像是大学里读ppt的老师，但是有很多跟武老师的人分数也很高，所以这两大派系的选择主要还是看自己。</p><hr /><p>周围基础不好的有跟周洋鑫的，</p><p>我本来不太了解这个人，就是最后的时候做了他出的三套卷，</p><p>猛然觉得，嗬这题出得好像真题，好有水平，然后一看发现很多都是真题改编的。</p><p>感觉应该也是个好老师。</p><hr /><p>我现在回忆，基础阶段和强化阶段在我脑海里是空白的，</p><p>我觉得这有可能就是我数学考成这个样子的原因。</p><p>像是盘古还未开天辟地时的混沌。</p><hr /><h2 id="section">4.408</h2><figure><img src="/images/image-20240302230426611.png"alt="image-20240302230426611" /><figcaption aria-hidden="true">image-20240302230426611</figcaption></figure><hr /><p>最后来个总结吧，再低也是我辛辛苦苦考出来的分</p><p>这个系统我这辈子估计也不会再进了。</p><p>（未写完，图之后贴）</p><figure><img src="/images/image-20240302230509125.png"alt="image-20240302230509125" /><figcaption aria-hidden="true">image-20240302230509125</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重新搞了博客</title>
    <link href="/2024/02/29/%E9%87%8D%E6%96%B0%E6%90%9E%E4%BA%86%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/02/29/%E9%87%8D%E6%96%B0%E6%90%9E%E4%BA%86%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>重新搞了博客，</p><p>21年刚开始整博客的时候，把博客放在了我自己的云服务器里，觉得既然买了就不用白不用，顺便练练运维啥的。</p><p>后来那个服务器承担了我很多的学习任务和尝试，所以经常遇到依赖地狱，</p><p>一旦十几个小时卡在某个依赖上毫无进展，我就直接气得重装整个服务器，</p><p>又懒得在外边套docker，所以连带着博客也得重装，我的评价是活该，</p><p>重装了几次之后就气坏了，懒得搞了，荒废了两年。</p><hr /><p>最终决定将博客作为一个lifelong的项目维持，为了省钱省力气挂在了github上，再重定向到我原来的域名，一举两得。</p><hr /><p>以前是把公众号的内容都搬过来，但是现在没那精力了，</p><p>因为微信公众号不支持md格式，导致我每次写完md之后还要贴到公众号上去精修一下，后来就演变成md只写草稿，再粘贴到公众号的编辑框写详细。</p><p>所以要么写个脚本，发哪个平台就全自动化移植到另一个平台，要么就两个平台单独更新吧，这边写点儿那边不让写的。</p><p>有空的时候我还是想完全自己写博客的前后端，现在用hexo主要是没时间，至于什么时候有时间，我觉得得等到上研究生之后，或者工作之后，或者退休之后了。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24考研的感受</title>
    <link href="/2023/12/24/24/"/>
    <url>/2023/12/24/24/</url>
    
    <content type="html"><![CDATA[<p>首发于微信公众号</p><p><ahref="https://mp.weixin.qq.com/s/Z36m4_W5Q_5h-bg2_d9yOA">我对于24考研的感受</a></p><p><br></p><h2 id="section">1</h2><p><br></p><p>无数次跟朋友调笑，说，考不上就二战，有什么大不了。</p><p>现在发现自己没办法二战。</p><p>因为没了半条命。</p><p>而且我是认真的。</p><p><br></p><hr /><p><br></p><p>这个月的很多时刻，我都在反复的想一个很浅显的道理，</p><p>就是为什么令人印象深刻的故事总是发生在各种大事中，过程里总是含有人的各种极端的情感，</p><p>而普通的生活就没太有观赏性。</p><p><br></p><hr /><p><br></p><p>为什么想这些，</p><p>因为每天都在痛苦里度过。</p><p>如果让我用一个词概括一下考研感受的话，我会在“痛苦“和”想死“之间选择。</p><p><br></p><hr /><p><br></p><p>我每天都会想哭很多次，</p><p>有时候能直接哭出来，让自己鼻腔一酸，眼泪就可以迅速往下掉一滩，</p><p>摘了眼镜，拿张卫生纸捂住下半张脸接住泪，就可以在沉默的哭着解压的同时继续背书看题。</p><p>剩下大部分时间，仍然痛苦的要死，想哭一下解解压，但尝试的时候一滴泪都流不出来，像枯井睁着黑漆漆的眼望天。然后乐一乐，自嘲一下自己连哭都哭不出来了，继续怀着想死的心背书看题。</p><p>每当这些时候就会想到这个道理，会觉得自己是某种舞台剧里的人物，因为感觉自己的精神状态和痛苦程度已经不属于正常人能经历的范畴了。</p><p><br></p><hr /><h2 id="section-1">2</h2><hr /><p><br></p><p>先谈痛苦的原因，</p><p>我考的是北京的数学一、英语一、统考408，</p><p>在整个考研领域算得上是顶尖体量、顶尖难度，考的也是顶尖学校。</p><p>我不后悔，因为如果我报了其他学校考出来分数超了这个学校的分数线，我会后悔一辈子，</p><p>相比之下，考不到这个学校的分数线被刷反而不会让我后悔，只会让我承认技不如人。</p><p><br></p><hr /><p><br></p><p>再加上我脑子很不好使。</p><p>我有多笨？举个小例子，我反复做了看了不知道多少遍往年真题，做了四五十套数学模拟，然而直到倒数第十天的时候，我才突然开窍，明白了10年真题的那道二次型为什么那么做，顺带才明白了一串儿类似的模拟题。</p><p>而且我明白的还是一个浅显的知识点。</p><p>每次这种突然开窍之后，我也哭，</p><p>不是喜悦的哭，是反应过来我突然开窍的东西到底有多简单的时候，会立马想到所有那些比我聪明的人早就花几秒的时间明白了这些知识点，而我要在桌前苦坐无数个斗转星移日日夜夜，用一次次的努力理解等待那个可能永远不会到来的质变。</p><p><br></p><hr /><p><br></p><p>然后我在12月18号的手机里留下了这句话：</p><p>“我不配留下后代。不然还让他和我一样这么蠢吗，还让他和我一样天天这么痛苦吗。”</p><p><br></p><hr /><p><br></p><p>再谈痛苦的内容。</p><p>我以前总是在所有事情上怪自己不努力，怪自己不自律。</p><p>因为我觉得我又菜又胖又丑，但我从未改变成功过。</p><p>所以我复盘我这辈子的时候，总是发现我没有任何一次竭尽全力过，</p><p>总是觉得我没有任何让我自己满意的事情。</p><p><br></p><p><br></p><p><br></p><p>现在有了。</p><p>无论最后结果怎么样，它都是。</p><p><br></p><p>因为我某一天发现，自从某个已经久远到我已经想不起来的时间点开始，我痛苦的内容就已经不是自己不努力了，而是自己天赋的上限、是这些受的苦、是这所有一切的最终意义。</p><p>我尽最大努力交付了。</p><p><br></p><p><br><br></p><p>十月的时候，我看到了努力的上限；十一月的时候，我开始想一些哲学的终极问题；十二月的时候，每天笑着哭，哭着笑，我觉得我变成了精神病。</p><p>现在考完的第一天，一小时前午睡做的梦还是昨天在数学考场上的心如死灰，做梦还是那用尽所有方法都解不出来的题，做梦还是已经冻僵了却还是一直在出冷汗的右手，做梦还是那死寂的氛围，如同一种无尽的阴影笼住我的人生。如果可以，我这辈子再也不想做数学了。之前哭是鼻酸，现在是喉咙深处酸，苦的让我想呕出我的内脏。</p><p>我已经竭尽全力，我在考前基本上完成了我应该做的所有任务，在冬日威海零下的考场上也发挥出了正常偏下的水平，我已经满足了，再来一年能改变的东西已经很少了。</p><p><br></p><p><br></p><p><br></p><p>这也是我最近不敢对答案的原因。</p><p>试想如果一个人做到了自己本不能做到的事情，如果一个人顶着巨大的压力满足了对自己来说超高的要求，却依然获得了预期外的坏结果，比如数学选择题错五个，而这是极其有可能发生的，我觉得我现在的精神状态会立马全线崩盘。</p><p>我已经足够努力，坚持到精神出问题，我已经很为自己自豪，但我还是希望那三个月无论寒暑雨雪每天都赶往图书馆的时刻，那些深夜无眠再挑灯火看文章的时刻，那些边哭边做题的时刻，那些闭馆时在暴风雪中深一脚浅一脚的时刻，都能有配得上它们的结果。</p><p><br></p><p><br></p><p><br></p><p>经历这一切后，我终于觉得，</p><p>我值得被爱了。</p><p>我要好好爱自己。</p><p><br></p><p><br></p><p><br></p><p><br></p><h2 id="section-2">3</h2><p><br></p><p><br></p><p>坂本龙一有首曲子，叫fullmoon，</p><p>用十一种语言叠加复述着一段话。</p><p>11月20号凌晨，我睡不着，坐在床下的黑暗里一直在听。</p><p><br></p><p><br></p><p>Because we don't know when we will die,</p><p>因为我们不知道死亡何时到达</p><p>we get to think of life as an inexhaustible well.</p><p>所以会把生命当成一座永不干枯的井</p><p>And yet everything happens only a certain number of times,</p><p>然而，所有事物都只出现一定的次数，</p><p>and a very small number really.</p><p>并且很少，真的</p><p>How many more times will you remember a certain afternoon of yourchildhood,</p><p>你会想起多少次童年中某个特定的下午，</p><p>some afternoon that's so deeply a part of your being that you can'teven conceive of your life without it?</p><p>某个深深成为你生命一部分的下午，如果没有它，你甚至无法想象自己的人生？</p><p>Perhaps four,or five times more?Perhaps not even that.</p><p>也许，四或五次吧？甚至可能没这么多。</p><p>How many more times will you watch the full moon rise?</p><p>你会看到满月升起几次呢?</p><p>Perhaps twenty.And yet it all seems limitless...</p><p>也许20次，然而这些都看似无穷﻿...</p><p><br></p><p><br></p><p><br></p><p>在最后的这几个月里，我每时每刻都清晰的知道，我所经历的这些事情看似无穷，实则有尽。</p><p>悲尽，识盈虚之有数。</p><p>我的感悟也会随着时间消逝，就像它们从未存在过。</p><p>考完过了一天，其实很多事情我就已经想不起来了，触发了自我保护机制。</p><p>心态也已经变成了完全不同的样子，所以现在的这些话只是在尽量还原模拟当时的心境。</p><p>考前的漫长日子里，我跟朋友们说，考完我要住在电影院，看小说、吃大餐、去运动、玩游戏、做美甲、剪掉我马上及腰的麻烦头发，玩一切我想玩的，尝试一切我没尝试过的。</p><p>现在下载回了所有娱乐软件，但连电影都不想看，小视频也不想刷，不想出门，什么都不想干，只想上床睡觉，桌下发呆。</p><p>抽离了所有东西，剩了一个空壳，需要慢慢用东西填回来。</p><p>像战场上回来的老兵，像刚坐牢出来的人。</p><p><br></p><p><br></p><p><br></p><p>像在一个舞台上缓缓退幕，</p><p>就到这里吧。</p><p>写这个东西的主要目的是，让来年的我万一落榜了还想二战的时候回来看看自己今年被折磨成了什么人不人鬼不鬼的样子，打消那个念头。</p><p>也没什么想说的了，可能四十八小时前的我还是能有满腹感慨往外倒的，但现在这个空壳是什么也说不出来了。</p><p><br></p><p><br><br></p><p>——留两首诗吧，我很喜欢的。</p><p><br></p><p>人生到处知何似，应似飞鸿踏雪泥。</p><p>泥上偶然留指爪，鸿飞那复计东西。</p><p>老僧已死成新塔，坏壁无由见旧题。</p><p>往日崎岖还记否，路长人困蹇驴嘶。</p><p><br></p><p>清夜无尘，月色如银。酒斟时、须满十分。</p><p>浮名浮利，虚苦劳神。叹隙中驹，石中火，梦中身。</p><p>虽抱文章，开口谁亲。且陶陶、乐尽天真。</p><p>几时归去，作个闲人。对一张琴，一壶酒，一溪云。</p><p><br></p><p><br></p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>白嫖Google相册无限空间实操</title>
    <link href="/2023/08/24/%E7%99%BD%E5%AB%96Google%E7%9B%B8%E5%86%8C%E6%97%A0%E9%99%90%E7%A9%BA%E9%97%B4%E5%AE%9E%E6%93%8D/"/>
    <url>/2023/08/24/%E7%99%BD%E5%AB%96Google%E7%9B%B8%E5%86%8C%E6%97%A0%E9%99%90%E7%A9%BA%E9%97%B4%E5%AE%9E%E6%93%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="白嫖google相册无限空间实操">白嫖Google相册无限空间实操</h1><p><br></p><p>准备：已root的手机</p><p>（我用Mi13Ultra，MIUI14.0.16）</p><p><br></p><p><br></p><p>众所周知，在pixel一代手机上用谷歌相册可以原图无限量上传。</p><p><br></p><figure><img src="/images/image-20240310231058617.png"alt="image-20240310231058617" /><figcaption aria-hidden="true">image-20240310231058617</figcaption></figure><p><br></p><p><br></p><p>所以要想白嫖，要么去闲鱼上淘个旧版pixel，要么把自己的手机伪装成pixel一代。</p><p><br></p><p>旧pixel1闲鱼价格两三百，我寻思着都能再买个硬盘了，也不想再多出个累赘，还得来回倒腾，配置主力机的自动更新什么的，</p><p>只看基带的话，Pixel和PixelXL用的是骁龙821，Modem支持的最大上行速率是150Mbps，换算就是18MB/s，虽然看起来还行，但这么多年了，网卡估计也不太行了，肯定还是用新手机香。</p><p><br></p><p><br></p><p>https://github.com/ButaiKirin/Pixel-2016-Permissions/releases</p><p>前几年试过用这个magisk模块，失败了，当时把自己主力账号的存储空间搞得爆红，gmail邮件都进不来，</p><p>今天又试了试，感觉它的功能只是伪装了本地的google相册，让它显示一句“此Pixel可以免费备份不限量的照片和视频”，实际上是掩耳盗铃。</p><p><br></p><p><br></p><p><br></p><p>时隔一年又发现了个新的模块，</p><p>https://github.com/BaltiApps/Pixelify-Google-Photos</p><p>界面长这样</p><p><br></p><figure><img src="/images/image-20240310231211423.png"alt="image-20240310231211423" /><figcaption aria-hidden="true">image-20240310231211423</figcaption></figure><p>但是用这个发行版本的时候一直出问题，伪装也不成功。</p><p><br></p><p>所以去软件的群看了看，</p><p>尝试了一下这个人发的版本，</p><p>这个版本除了能成功以外，最大的区别就是可伪装的型号更多了</p><p><br></p><figure><img src="/images/image-20240310231224750.png"alt="image-20240310231224750" /><figcaption aria-hidden="true">image-20240310231224750</figcaption></figure><figure><img src="/images/image-20240310231238022.png"alt="image-20240310231238022" /><figcaption aria-hidden="true">image-20240310231238022</figcaption></figure><p>看应用签名，好像是这哥们自己搞的版本，发行组织就是他的博客域名，所以要想用的话，自己去群里或者这个博客里找。</p><figure><img src="/images/image-20240310231301486.png"alt="image-20240310231301486" /><figcaption aria-hidden="true">image-20240310231301486</figcaption></figure><p>这软件一开始装的时候会提示要在lsposed里打开模块后重启，实测也不用重启，lsposed里打开之后设置停止运行再打开就行。</p><p><br></p><p>谷歌相册：https://photos.google.com/</p><p>谷歌云盘：https://drive.google.com/</p><p><br></p><p>能够正常无限原画质备份的现象是：只有谷歌相册里能找到备份了的照片和视频，而谷歌云盘里不仅不占用存储空间，也看不见。</p><p><br></p><p>最后成功</p><figure><img src="/images/image-20240310231319864.png"alt="image-20240310231319864" /><figcaption aria-hidden="true">image-20240310231319864</figcaption></figure><figure><img src="/images/image-20240310231335363.png"alt="image-20240310231335363" /><figcaption aria-hidden="true">image-20240310231335363</figcaption></figure><p>（成功标志：网页端有照片的情况下显示0B）</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>折腾校园卡24小时后，我后悔了</title>
    <link href="/2023/07/29/%E6%8A%98%E8%85%BE%E6%A0%A1%E5%9B%AD%E5%8D%A124%E5%B0%8F%E6%97%B6%E5%90%8E%EF%BC%8C%E6%88%91%E5%90%8E%E6%82%94%E4%BA%86/"/>
    <url>/2023/07/29/%E6%8A%98%E8%85%BE%E6%A0%A1%E5%9B%AD%E5%8D%A124%E5%B0%8F%E6%97%B6%E5%90%8E%EF%BC%8C%E6%88%91%E5%90%8E%E6%82%94%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h1 id="折腾校园卡24小时后我后悔了">折腾校园卡24小时后，我后悔了</h1><p><br></p><p>我平常固定在图书馆某层中间的一个位置自习，旁边是一面巨大的窗子，采光好，还有窗台让我放书。</p><figure><img src="/images/image-20240310232415490.png"alt="image-20240310232415490" /><figcaption aria-hidden="true">image-20240310232415490</figcaption></figure><p>某天正午，我觉得很热，打开了我那片区域图书馆的空调，一个女生接着走过去关了。</p><p>好的，既然不让我开，那我搬去一直开着空调的地方。</p><p>但是开着空调的地方采光又不好，来回搬书又太麻烦。</p><p>于是我想，能不能预约两个座位，这样我就不用来回搬了，热的时候去开空调那里，暗的时候去采光好那里。</p><p><br></p><hr /><p><br></p><p>想用两个座位，就需要另外一个人的学生卡。</p><p><br></p><p>有个朋友，现在不在学校，未来一年也不会进图书馆，所以用他的学生卡就是最好的选择。</p><p>征求他的同意之后，我们开始讨论如何让我在没有卡的情况下使用他的卡进行预约。</p><p>他的卡留在了宿舍，但恰巧一年多前他买了个读卡器，恰巧当时他破解卡之后把dump文件（卡里边的内容）截图发给了我，截图里恰巧有我所需要的全部信息。</p><p>恰巧我当时也很好奇，借用了他的读卡器，自己也暴力破解了自己的校园卡，但早就忘了当时把破解出来的dump文件存到了哪里，有没有删，</p><p>于是我用everything正则搜*.dump，万幸，在回收站找到了当时校园卡和银行卡的dump文件，然后还原了回去。</p><p><br></p><figure><img src="/images/image-20240310232433541.png"alt="image-20240310232433541" /><figcaption aria-hidden="true">image-20240310232433541</figcaption></figure><p>另外，某校用的学生卡应该是IC卡中的一种，NXP MIFARE Classic1k，共分为12个扇区，</p><p><br></p><figure><img src="/images/image-20240310232444160.png"alt="image-20240310232444160" /><figcaption aria-hidden="true">image-20240310232444160</figcaption></figure><p>0-5这六个扇区是密钥加密过的，nfc读取只能读出它位于0扇区0块的卡号，因为在nfc第一次读取卡的实体门卡页面中显示卡号，但模拟的时候提示说：加密卡只能模拟卡号（厂商码能不能不确定），</p><p>用十六进制查看器可以看出，后边的12345里存放了学号与姓名和一些其他的东西。</p><p><br></p><figure><img src="/images/image-20240310232509156.png"alt="image-20240310232509156" /><figcaption aria-hidden="true">image-20240310232509156</figcaption></figure><p>但手机和手环的nfc依然可以预约图书馆，说明图书馆的读卡机只需要读到卡号，不需要加密卡的其他部分，所以我只需要用nfc模拟出他的卡号，当然，这是我后期才明白过来的。</p><p>通过补办新卡让旧卡报废来看，卡号这玩意儿也是唯一的，估计是补办的时候会把新卡号插到数据库里覆盖旧卡号，达到每人一卡的功能。</p><p><br></p><hr /><p><br></p><p>于是现在的总体情况是，我拥有我卡的dump文件，他卡的dump文件，还有一张我在用的校园卡，还有一张之前找不到的，补办之后又找到，所以现在报废了的卡，还有一部root了的手机，</p><p>其它包括读卡器写卡器空白卡什么的，统统没有。</p><p>最终目的是用手机模拟出他的卡。</p><p><br></p><p>于是开始尝试各个软件能不能用，分别有什么功能，这是一个漫长的过程，</p><p>最后选定了四个软件，通过他们功能的配合达成目的，分别是</p><p>NFC Card Emulator Pro (root)</p><p>NFC Reader Tool Pro</p><p>Mifare Classic Tool</p><p>NFC Tools Pro</p><p><br></p><figure><img src="/images/image-20240310232531502.png"alt="image-20240310232531502" /><figcaption aria-hidden="true">image-20240310232531502</figcaption></figure><figure><img src="/images/image-20240310232539840.png"alt="image-20240310232539840" /><figcaption aria-hidden="true">image-20240310232539840</figcaption></figure><p>MCT就是Mifare ClassicTool，它无法自己添加dump，只能用现场读入的标签信息保存后再进行写入或修改，我主要用来读卡后写卡。</p><p>首先，0-5扇区是加密了的，MCT的读取标签需要密钥，写卡也是，但我只有dump文件，没有密钥，</p><figure><img src="/images/image-20240310232553736.png"alt="image-20240310232553736" /><figcaption aria-hidden="true">image-20240310232553736</figcaption></figure><p><br></p><p>但有了dump文件就相当于拥有了解密后的卡，按理来说能够从dump里反推出它的密钥。</p><p>所以我找到了NFC Reader ToolPro，它可以自己写dump，然后通过dump文件自动生成密钥文件，</p><p>当然，写的过程比较痛苦，因为只能在它自己新建的dump文件上修改，改成自己需要的，所以要自己在手机上写那6个扇区的数字。</p><p>最后每个dump文件都生成了一个六行的密钥，再导入到MCT中，此时发现可以成功读卡了。</p><p><br></p><p>此时我的手机莫名其妙开始疯狂自动重启，我排除了过热原因，还有电池原因（半个月前刚换），剩下的有可能是电源键问题，因为最近电源键不太灵敏，还有可能是换电池的时候线装的糙了，电池的断触问题，或者主板问题。</p><p>反正无论是什么，都很吓人，于是我当天备份了一遍我的手机数据（后文会极其感谢自己此时备份了一下）。</p><p><br></p><p>有了密钥，我就可以用MCT读写我的卡，此时我尝试了两种情况，</p><p>第一就是格式化，实际操作后发现除了0扇区0块，其它都能格式化到出厂状态，也就是这样</p><figure><img src="/images/image-20240310232605791.png"alt="image-20240310232605791" /><figcaption aria-hidden="true">image-20240310232605791</figcaption></figure><p><br></p><p>之后我用这个卡去图书馆刷卡机上刷了一下，发现还是可以读取，说明图书馆真的只认卡号（或加上厂商码）。</p><figure><img src="/images/image-20240310232615875.png"alt="image-20240310232615875" /><figcaption aria-hidden="true">image-20240310232615875</figcaption></figure><figure><img src="/images/image-20240310232625800.png"alt="image-20240310232625800" /><figcaption aria-hidden="true">image-20240310232625800</figcaption></figure><p><br></p><p>第二就是将他的dump文件中除了卡号的部分写入到我的卡中，也就是一个卡里有我的卡号，和解密后他的学号姓名，</p><p>下午去食堂吃饭时刷了一下，发现没有反应，说明食堂消费的读卡机不仅需要卡号，还需要同时验证里边的加密信息。</p><p><br></p><figure><img src="/images/image-20240310232637850.png"alt="image-20240310232637850" /><figcaption aria-hidden="true">image-20240310232637850</figcaption></figure><p><br></p><figure><img src="/images/image-20240310232645467.png"alt="image-20240310232645467" /><figcaption aria-hidden="true">image-20240310232645467</figcaption></figure><p>后来我反应过来，</p><p>既然图书馆只需要卡号，我也有了他的卡号，</p><p>我的手机又是root了的，理论上说我对我的手机具有绝对掌控权，</p><p>所以按理说我可以通过直接修改nfc配置文件的方式，让nfc直接伪装为他的卡号。</p><p><br></p><p>但来回改配置文件肯定很麻烦，因为我不止要用他这一个卡，而且同时还需要修改卡的频率之类的，</p><p><br></p><figure><img src="/images/image-20240310232701127.png"alt="image-20240310232701127" /><figcaption aria-hidden="true">image-20240310232701127</figcaption></figure><p><br></p><p>所以我开始寻找，有没有能自动化的帮我做好这一切伪装的软件。</p><p><br></p><p>有是有，但看起来做的很好的NFCTools注册就需要49.9，其它的非开源软件大同小异，都是在让我还未确定他们的软件能不能正常工作时就要收我十几块钱，我这人比较抠搜，而且找不到破解版。</p><figure><img src="/images/image-20240310232710377.png"alt="image-20240310232710377" /><figcaption aria-hidden="true">image-20240310232710377</figcaption></figure><p><br><br></p><p>后来，我终于发现了一款NFC Card Emulator Pro(root)：NFC卡模拟，它有手动添加卡号再用nfc模拟的功能，当然，需要root权限，谷歌商店6美金，没钱，用的52pojie的版本。</p><p>但无论如何，它都提示我获取不到root权限，而且它并没有给magisk发出弹窗的请求，</p><figure><img src="/images/image-20240310232725353.png"alt="image-20240310232725353" /><figcaption aria-hidden="true">image-20240310232725353</figcaption></figure><p><br></p><p>但我看到，我的那些步数修改器和爱玩机工作箱之类的需要root权限的软件都是在正常运行的，magisk也正常，甚至把请求响应改成自动允许也不行，我百思不得其解，于是放弃。</p><figure><img src="/images/image-20240310232735014.png"alt="image-20240310232735014" /><figcaption aria-hidden="true">image-20240310232735014</figcaption></figure><p><br></p><p>我接着转向寻找开源软件，但它们都是最晚4年前，最早能追溯到7年前的仓库，对于现在的安卓11来说可能太过时了，于是在功能上都出现了一些严重的问题，还有的甚至没有发行版，需要我自己用AndroidStudio构建。</p><figure><img src="/images/image-20240310232744665.png"alt="image-20240310232744665" /><figcaption aria-hidden="true">image-20240310232744665</figcaption></figure><p><br></p><p>（后期get rootaccess后发现也不能用，且作者多年前看到有比他好的NFC卡模拟pro之后就不再维护了）</p><figure><img src="/images/image-20240310232752539.png"alt="image-20240310232752539" /><figcaption aria-hidden="true">image-20240310232752539</figcaption></figure><p><br></p><p>这时陷入了僵局，哪个方法都走不通。我就只能去继续学最原始的直接修改libnfc.conf的方法，</p><p>但是直接修改系统的文件，首先你得先找到它，这就需要一个能获取root权限的文件资源管理器，最终选定了MT管理器，真的很好用，但是它也无法获取root权限，我就开始怀疑是magisk的问题，</p><p>对于NFC卡模拟那个软件，我也还是不甘心，</p><p>此时我突然看到一个贴吧的帖子，一个人说，要主动给软件授权root的话，可以在爱玩机工具箱里找到应用管理里的唤醒root权限，</p><figure><img src="/images/image-20240310232804770.png"alt="image-20240310232804770" /><figcaption aria-hidden="true">image-20240310232804770</figcaption></figure><p><br></p><p>就这么寥寥几句，下边好像只有两个人说他的方法有用，但却解决了我的众多问题，</p><p>正好我也有爱玩机工具箱，上手一试，真的成功了，那两个无法自己获取root权限的软件也在magisk的超级用户栏里出现了对应的按钮。</p><figure><img src="/images/image-20240310232814804.png"alt="image-20240310232814804" /><figcaption aria-hidden="true">image-20240310232814804</figcaption></figure><p><br></p><p>我大喜过望，我以为现在万事俱备，东风已来，其实路途才刚刚过半。</p><p>在赋权之后，我颤抖的打开了NFC模拟器，输入他的卡号，</p><p>创建成功，yes！</p><p><br></p><p>但开始nfc模拟的时候，又出现了一个问题：</p><p>软件提示我的vendor分区无法读写。</p><figure><img src="/images/image-20240310232825585.png"alt="image-20240310232825585" /><figcaption aria-hidden="true">image-20240310232825585</figcaption></figure><p><br></p><p>也就是说，要读写的nfc配置文件放在vendor分区里，而那个分区我现在依然没有读写的权力。</p><p>于是我需要去找到，让vendor分区能被修改的方法。</p><p><br></p><figure><img src="/images/image-20240310232837432.png"alt="image-20240310232837432" /><figcaption aria-hidden="true">image-20240310232837432</figcaption></figure><p>（此时，刷入magisk卡模块这个方法失败）</p><p><br></p><figure><img src="/images/image-20240310232847093.png"alt="image-20240310232847093" /><figcaption aria-hidden="true">image-20240310232847093</figcaption></figure><p>我没想到，修改vendor分区是一个巨大的难题，网上几乎所有的方法在Android11之后都失效了，所以我按照时间搜索近一年内的解锁vendor教程，只找到了一个看起来可行，且详细教学的帖子，</p><p>出厂安卓11机型解锁system分区教程_安卓11解锁system分区</p><p>https://blog.csdn.net/oAiYinSiTan12/article/details/119655706</p><p>如文中所说，解锁system的原理就是去除vbmeta检验(简称AVB2.0检验)</p><p><br></p><p>整体的流程看起来复杂，其实——做起来更复杂，</p><p>总体流程是，将vendor分区提取出来，修改/vendor/etc/fstab.qcom，去除里边的vab选项，打包回去，再刷入手机，</p><p>每一步里都有大大小小的坑。</p><p>提取vendor这一步，我手机上有termux，在termux里安装ubuntu，ubuntu里装上DNA工具，DNA工具的gitee主页的readme文件因为“可能违规”无法显示（离谱），所以需要clone到本地才能查看，</p><figure><img src="/images/image-20240310232907609.png"alt="image-20240310232907609" /><figcaption aria-hidden="true">image-20240310232907609</figcaption></figure><p><br></p><p>接着，提取vendor分区的脚本，这里又有坑，就像这个视频教程下面第一个评论www.bilibili.com/video/BV1xV411n7Ys/</p><p>“fastboot --disable-verity --disable-verification flash vbmetavbmeta.img的缘故，并没有VAB分区，所以脚本里的vender_a/vender_b需要变更成vender，同理system亦是如此。最后fastbootd刷入vender.img也没有vender_a/vender_b，使用fastbootflash vender vender.img刷入即可。”</p><p>我之前也试着执行过fastboot --disable-verity --disable-verificationflash vbmeta vbmeta.img这条命令，和他的情况是一样的，</p><p>但后来我发现，mi10的手机架构好像本来就没有ab分区，所以需要把脚本里的vendor_a改成vendor，后边的fastbootd刷入vendor时也是一样。</p><figure><img src="/images/image-20240310232923392.png"alt="image-20240310232923392" /><figcaption aria-hidden="true">image-20240310232923392</figcaption></figure><p><br></p><p>下一步修改，要注意我们现在用的DNA分解出来的size.txt不在视频里的地方了，需要自己在那几个文件夹下找一找。</p><p>开始用DNA打包的时候，还要注意，视频里的08是合成img，我们现在clone到的版本改成了06是img，而且下面的命令提示也改变了，最后打包出来的名字也不是vendor_dna.img而是直接的vendor.img，放的目录也变了，也需要自己去找找。</p><figure><img src="/images/image-20240310232931612.png"alt="image-20240310232931612" /><figcaption aria-hidden="true">image-20240310232931612</figcaption></figure><p><br></p><p>打包之后就可以刷入了，没想到我在这儿出现了严重的岔子，手机变砖了。</p><figure><img src="/images/image-20240310232939313.png"alt="image-20240310232939313" /><figcaption aria-hidden="true">image-20240310232939313</figcaption></figure><p><br></p><p>由于刷入的时候一直提示：Not enough space to resizepartition，空间不足，于是我开始删其它的分区，但无论怎么删，还是一直提示空间不足，我渐渐开始急了，</p><p>最后直接fastboot -w，意味着把我所有的用户数据也抹除了，</p><figure><img src="/images/image-20240310232946373.png"alt="image-20240310232946373" /><figcaption aria-hidden="true">image-20240310232946373</figcaption></figure><p><br></p><figure><img src="/images/image-20240310232956621.png"alt="image-20240310232956621" /><figcaption aria-hidden="true">image-20240310232956621</figcaption></figure><p><br></p><p>此时终于能把vendor刷进去了。</p><figure><img src="/images/image-20240310233004801.png"alt="image-20240310233004801" /><figcaption aria-hidden="true">image-20240310233004801</figcaption></figure><p><br></p><p>但由于我在刷的过程中出了很多奇怪的问题，所以刷入之后重启时，开始自动无限重启。</p><figure><img src="/images/image-20240310233012266.png"alt="image-20240310233012266" /><figcaption aria-hidden="true">image-20240310233012266</figcaption></figure><p><br></p><p>后来我又把自己备份的原来的vendor刷了进去，但无力回天，还是在无限重启，所以我决定直接进recovery双清，然后线刷进系统。</p><figure><img src="/images/image-20240310233020510.png"alt="image-20240310233020510" /><figcaption aria-hidden="true">image-20240310233020510</figcaption></figure><p><br></p><p>后来，线刷出了问题，找了二十分钟问题之后，发现是我下错了线刷包型号，10pro下成了10...极其低级的错误，但也合理，当时接近一点，我的脑子已经不太转动了。</p><figure><img src="/images/image-20240310233031177.png"alt="image-20240310233031177" /><figcaption aria-hidden="true">image-20240310233031177</figcaption></figure><figure><img src="/images/image-20240310233038422.png"alt="image-20240310233038422" /><figcaption aria-hidden="true">image-20240310233038422</figcaption></figure><p><br></p><p>我又去下载了一个mi10pro对应的包，因为小米社区的链接下得很慢，当时已经一两点了，所以我去别的地方找了一个下的快的（也没快多少），结果解压之后才发现是卡刷包，意味着又下错了，又浪费了5G流量和半小时。</p><p>最后，我终于长了记性，去小米社区下了10pro线刷包，凌晨网很慢，边看古相思曲边等，等了一小时。</p><p>刷入的时候又出了幺蛾子，当时看古相思曲的播放窗口正好挡住了下边的这个选项，默认选项是全部删除并lock，我就直接开始刷入，当我发现的时候，已经刷入了一半了，</p><p>当时一瞬间汗毛直立，头皮发麻，要是刷入之后还重启不了，我还把BL锁又锁上了，那在未解BL锁的情况下想刷机可就难如登天了。</p><p>最后还好刷入之后成功开机了，但同时BL锁被锁上了。</p><figure><img src="/images/image-20240310233048251.png"alt="image-20240310233048251" /><figcaption aria-hidden="true">image-20240310233048251</figcaption></figure><p><br></p><p>但我还想再刷入一遍修改过的vendor试一试，所以又得打开BL锁，于是又要解锁，还好第一次解锁之后不需要再等168小时，我又开了BL锁，之后又刷入了一遍vendor，这次刷入成功了，手机不再无限重启了。</p><p><br></p><p>最初的目标，解锁vendor是为了让NFC模拟器获取修改vendor的权限，</p><p>经过这么一折腾，我的手机恢复到了出厂状态，用户数据也没了，但我在两天前备份了一遍手机，所以再导入。</p><p>重新装完一遍系统之后再模拟，发现又在报错，之前是vendor：read onlyfile，现在的报错变成了No space left ondevice，但这次，帮助手册中的刷入magisk卡模拟成功了。</p><figure><img src="/images/image-20240310233057214.png"alt="image-20240310233057214" /><figcaption aria-hidden="true">image-20240310233057214</figcaption></figure><p><br></p><p>最后，在凌晨的将近五点，我终于模拟成功了。</p><figure><img src="/images/image-20240310233107013.png"alt="image-20240310233107013" /><figcaption aria-hidden="true">image-20240310233107013</figcaption></figure><p><br></p><hr /><p>你以为是个热血沸腾的good ending？不是的。</p><figure><img src="/images/image-20240310233140642.png"alt="image-20240310233140642" /><figcaption aria-hidden="true">image-20240310233140642</figcaption></figure><figure><img src="/images/image-20240310233148562.png"alt="image-20240310233148562" /><figcaption aria-hidden="true">image-20240310233148562</figcaption></figure><figure><img src="/images/image-20240310233157987.png"alt="image-20240310233157987" /><figcaption aria-hidden="true">image-20240310233157987</figcaption></figure><figure><img src="/images/image-20240310233206027.png"alt="image-20240310233206027" /><figcaption aria-hidden="true">image-20240310233206027</figcaption></figure><figure><img src="/images/image-20240310233212312.png"alt="image-20240310233212312" /><figcaption aria-hidden="true">image-20240310233212312</figcaption></figure><p>凌晨模拟成功后，我以为没问题了，于是买了杯咖啡，想去校外取咖啡的时候顺便经过图书馆测验一下就走，接着回来写这篇文章。</p><p><br></p><p>但没想到它模拟出来的是随机数。</p><p>在图书馆二楼刷卡机前找了个凳子，调试了半小时，无果，</p><p>图书馆没开空调，热的要死，去拿咖啡，</p><p>在咖啡店里坐着，继续调试了半小时，无果。</p><p><br></p><p>最后受不了了，索性放弃。</p><hr /><p>我在一开始就知道，我碰到的这些所有的问题其实几乎都能通过简简单单的一个CUID白卡解决，</p><p>过程中，我也无数次想到，如果有个白卡我就不用绕这么大一个圈子了，</p><p>所以我当时就下单了读卡器，商家赠送ID，UID，CUID，7月31送到。</p><figure><img src="/images/image-20240310233222395.png"alt="image-20240310233222395" /><figcaption aria-hidden="true">image-20240310233222395</figcaption></figure><p><br></p><p>但我就是想看看，在送到前的这几天里，我不靠读卡器和空白卡，仅靠现有的资源能不能解决问题。</p><p>虽然我失败了，但结论其实是能，只是我现在已经不想再去探究到底哪里出了问题了。</p><p>但我还是后悔了，因为我耗费了整整两天的时间，如果我手边有个五块钱的白卡，dump写入—导入手机NFC—完成，所有的流程不会超过五分钟。</p><p>为什么过程里我一直不想放弃，因为每一步看起来都像是最后一步——获取了root权限应该就能模拟成功了——vendor重新挂载应该就能成功了——刷入之后应该就能成功了——变砖了，但线刷之后再刷入一遍应该就能成功了......</p><p>没想到它就像一个无限往下递归的栈，我困在沉没成本里，永远不知道自己下一步是不是弹出。</p><p>我不想在这结尾处上升到浪子回头、及时收手之类的话，没有意义，</p><p>因为我知道，即使我现在后悔浪费了时间，下一次面对类似情境时，我也依然会去全力探究，</p><p>只是很多事情没有预想中的结果罢了。</p>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>威联通Nas配置Zerotier自建Planet踩坑记录</title>
    <link href="/2023/01/31/%E5%A8%81%E8%81%94%E9%80%9ANas%E9%85%8D%E7%BD%AEZerotier%E8%87%AA%E5%BB%BAPlanet%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/31/%E5%A8%81%E8%81%94%E9%80%9ANas%E9%85%8D%E7%BD%AEZerotier%E8%87%AA%E5%BB%BAPlanet%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><br></p><p><br></p><h1id="威联通nas配置zerotier自建planet踩坑记录">威联通Nas配置Zerotier自建Planet踩坑记录</h1><p><br></p><p><br></p><h2 id="用到的东西">0.用到的东西：</h2><p>威联通*1，型号：TS-264C</p><p>腾讯云服务器*1</p><p>Mi10pro*1</p><p>Win11*1</p><p><br></p><h2 id="自建planet">1.自建Planet</h2><p><br></p><h3 id="倒腾一键脚本半天没成功">1.1倒腾一键脚本半天，没成功</h3><p>主要是看的这个教程：</p><p><ahref="https://zhuanlan.zhihu.com/p/544807922">构建Zerotier私有根服务器(Planet)，实现比MOON更稳定的内网穿透- 知乎 (zhihu.com)</a></p><p>系统用了ubuntu18，20，22的LTS版本，都没成功</p><p>除了腾讯的服务器，我还用我另外一个Ucloud的1核2G的试了试，也不行</p><p><br></p><figure><img src="/images/image-20240310224426282.png"alt="image-20240310224426282" /><figcaption aria-hidden="true">image-20240310224426282</figcaption></figure><p><br></p><p><br></p><p>中间安装时出现了一个报错，</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">In <span class="hljs-keyword">file</span> included <span class="hljs-keyword">from</span> ..<span class="hljs-regexp">/../</span>osdep/OSUtils.cpp:<span class="hljs-number">44</span>:<br>..<span class="hljs-regexp">/../</span>osdep<span class="hljs-regexp">/OSUtils.hpp:46:10: fatal error: nlohmann/</span>json.hpp: No such <span class="hljs-keyword">file</span> or directory<br>  <span class="hljs-number">46</span> | #<span class="hljs-keyword">include</span> &lt;nlohmann/json.hpp&gt;<br>    |         ^~~~~~~~~~~~~~~~~~~<br>compilation terminated.<br>In <span class="hljs-keyword">file</span> included <span class="hljs-keyword">from</span> mkworld.cpp:<span class="hljs-number">49</span>:<br>..<span class="hljs-regexp">/../</span>osdep<span class="hljs-regexp">/OSUtils.hpp:46:10: fatal error: nlohmann/</span>json.hpp: No such <span class="hljs-keyword">file</span> or directory<br>  <span class="hljs-number">46</span> | #<span class="hljs-keyword">include</span> &lt;nlohmann/json.hpp&gt;<br>    |         ^~~~~~~~~~~~~~~~~~~<br>compilation terminated.<br></code></pre></td></tr></table></figure><p>从网上找的解决办法是</p><p>sudo apt-get install nlohmann-json3-dev</p><p>不报错了，但还是不行</p><p>主要就是卡在这一步</p><figure><img src="/images/image-20240310224443196.png"alt="image-20240310224443196" /><figcaption aria-hidden="true">image-20240310224443196</figcaption></figure><p>我打开我的页面会显示：服务器未发送任何数据，并且在此之前我是检查过内部防火墙和云服务器控制台防火墙都打开了的。</p><p>所以这个方法在我坐在电脑前坐牢了五六个小时之后终于被pass掉</p><p><br></p><h3 id="用docker安装">1.2用docker安装</h3><p>我主要成功的方法是这个</p><p><ahref="https://post.smzdm.com/p/apxkx2m7/">放弃moon节点，直接搭建Zerotier根服务器<em>软件应用</em>什么值得买(smzdm.com)</a></p><p><br></p><p>结合着这个看</p><p><a href="https://zhuanlan.zhihu.com/p/573746661">Zerotier搭建私有根服务器及创建虚拟局域网完整教程 - 知乎 (zhihu.com)</a></p><figure><img src="/images/image-20240310224459360.png"alt="image-20240310224459360" /><figcaption aria-hidden="true">image-20240310224459360</figcaption></figure><p>只看到五以前的内容，因为感觉Nas不是正常的linux系统</p><p><br></p><h2 id="威联通nas安装zerotier">2.威联通Nas安装Zerotier</h2><p><br></p><p>看的这个教程</p><p><ahref="https://zhuanlan.zhihu.com/p/332733170">高速远程访问NAS——用Zerotier免费实现内网穿透，远程管理NAS中心！-知乎 (zhihu.com)</a></p><p>从这里往下开始看</p><figure><img src="/images/image-20240310224518496.png"alt="image-20240310224518496" /><figcaption aria-hidden="true">image-20240310224518496</figcaption></figure><p>看到这里结束</p><p><br></p><figure><img src="/images/image-20240310225006482.png"alt="image-20240310225006482" /><figcaption aria-hidden="true">image-20240310225006482</figcaption></figure><p>再回到</p><p>构建Zerotier私有根服务器(Planet)，实现比MOON更稳定的内网穿透 - 知乎(zhihu.com)</p><p>https://zhuanlan.zhihu.com/p/544807922</p><p>这个教程，看linux篇，替换一下planet</p><h5 id="感觉自己是伞兵的一些操作">感觉自己是伞兵的一些操作：</h5><p>几个小时之间记得自己明明能在命令行界面找到.qpkg但用winscp时找不到，最后发现自己没设置显示隐藏文件</p><p>nas的系统找不到service和systemctl命令，我替换planet之后没办法用命令重启zerotier服务，所以我选择在nas的appcenter里停止再重启zerotier，但我猜这样干的话他的服务进程其实也还是没有停止的，即使加入了网络，在网络的后台也看不到设备，于是又在这儿卡了一小时，</p><p>最终解决方法就是直接重启Nas，于是终于能在网络后台发现nas了</p><p><br></p><h2 id="手机安装zerotier">3.手机安装Zerotier</h2><p>Zerotier 非官方安卓客户端发布：支持自建 Moon 节点 - 知乎(zhihu.com)</p><p>https://zhuanlan.zhihu.com/p/362884740</p><p>用的这个，大佬不愧是大佬，配置起来极其方便。</p><p><br></p><h2 id="win11安装zerotier">4.win11安装Zerotier</h2><p>明明按理说应该是最简单的，但我搞了一天多了，还没成功</p><p>安装倒是没问题，但有其他的问题，首先是Node：unknown</p><p>市面上所有解决nodeunknown的方案只有几个，我都试了，没用</p><p>我研究了研究，zerotier会给电脑新建一个虚拟网卡，但我去我的网络适配器里看了看，没有</p><p>运行zerotier的时候也会闪过一个错误</p><figure><img src="/images/image-20240310225018232.png"alt="image-20240310225018232" /><figcaption aria-hidden="true">image-20240310225018232</figcaption></figure><p>找不到这个文件，我看了看，确实没有，网上说是驱动有问题，我手动安装了那个inf文件，没用，还是没有</p><p>网上说是版本问题，不适配，我下了很多其他版本，也没用。</p><p>不知道是win11的问题还是我电脑的问题</p><p><br></p><p><br></p><p>几个小时后来更新：</p><p>看这个，虽然已经装过四五个版本的了，但死马当活马医还是想试一下，于是成功了，nodeid有了</p><p>win11无法正常使用zerotier - 『悬赏问答区』 - 吾爱破解 - LCG - LSG|安卓破解|病毒分析|www.52pojie.cn</p><p>https://www.52pojie.cn/thread-1660407-1-1.html</p><p>装这个之前我卸载了深信服之类的和网卡沾那么一点边的东西，不知道是不是这个问题</p><p><br></p><figure><img src="/images/image-20240310225029560.png"alt="image-20240310225029560" /><figcaption aria-hidden="true">image-20240310225029560</figcaption></figure><p>啊这就是成功的感觉，运行的时候终于不报错了，看了看安装文件夹里也有zerotier-one.port了，就连在电脑服务里面重启zerotier服务的时候，停止和启动都比原来快超级多。</p><p><br></p><p>虽然过程是玄学的，但结果是好的。</p><p><br></p><p>ps，这个教程也不错</p><p><ahref="https://shiruixuan.gitee.io/2022/09/16/docker-zerotier-planet/">搭建私有ZeroTier Planet 根服务器（Docker 版） | shiruixuan (gitee.io)</a></p><p>pss，我为什么不用ipv6？</p><p>家里宽带是移动的，只有ipv4没有ipv6，都说要去光猫后台改，我也想顺便把我家光猫改成桥接模式，昨晚光猫和电脑用网线直连，依然进不去光猫后台，不是用户名密码不对的那种，是拒绝访问或者无响应的那种，并且猫上啥也没写，我觉得移动有可能是直接给用户堵死了这条路，上网一搜在某个论坛发现有人问宽带小哥为啥进不去猫，小哥说现在都改成云防火墙了，他们现在也进不去了，我就放弃了。</p><p>主要是即使用了ipv6，比起zerotier的方案还是有挺多不方便的地方。</p><p><br></p><p><br></p>]]></content>
    
    
    <categories>
      
      <category>Nas</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>标题</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>Hello there!👋</p><p>My name is LT, a senior Computer Science and Technology major atShandong University.</p><p>I have a passion for all things computer-related.</p><p>Besides being a techie, I'm also an avid movie buff and a dedicatedreader of novels.</p><p>You can think of me as a cyber hamster🐹, perpetually scurryingthrough the boundless corridors of the internet.</p><p>I run my own public WeChat account "LT想吃黑芝麻汤圆,"</p><p>My amateur radio call sign is BI4ISA,</p><p>and I am on my journey to becoming a full-stack engineer.👩🏻‍💻</p><p>Should you wish to reach out, my email is sdtaltt@163.com. I would bedelighted to connect.</p>]]></content>
    
  </entry>
  
  
  
</search>
