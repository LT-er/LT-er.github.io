<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DAY3日寄-苍穹外卖02-毕设AI</title>
    <link href="/2024/03/09/DAY3/"/>
    <url>/2024/03/09/DAY3/</url>
    
    <content type="html"><![CDATA[<h4 id="我有个部署在github仓库里的个人博客，网页前端用hexo框架，用typora编辑器进行md格式的写作，上传md文件生成网页，但是我的md文件里贴了大量的图片，比如说这种，如何让这些在本地的图片自动跟着我的md文件一起上传"><a href="#我有个部署在github仓库里的个人博客，网页前端用hexo框架，用typora编辑器进行md格式的写作，上传md文件生成网页，但是我的md文件里贴了大量的图片，比如说这种，如何让这些在本地的图片自动跟着我的md文件一起上传" class="headerlink" title="我有个部署在github仓库里的个人博客，网页前端用hexo框架，用typora编辑器进行md格式的写作，上传md文件生成网页，但是我的md文件里贴了大量的图片，比如说这种，如何让这些在本地的图片自动跟着我的md文件一起上传"></a>我有个部署在github仓库里的个人博客，网页前端用hexo框架，用typora编辑器进行md格式的写作，上传md文件生成网页，但是我的md文件里贴了大量的图片，比如说这种<img src="C:\Users\14097\AppData\Roaming\Typora\typora-user-images\image-20240308184049708.png" alt="image-20240308184049708">，如何让这些在本地的图片自动跟着我的md文件一起上传</h4><p>为了让本地的图片能够与Markdown文件一起上传，并且能够在GitHub Pages上的个人博客中正确显示，你需要采取以下步骤：</p><ol><li><strong>将图片移动到项目仓库中</strong>：首先，你需要将所有本地的图片文件移到你的GitHub仓库对应的目录中。一般情况下，Hexo框架会有一个专门用来存放静态文件的文件夹，如<code>source</code>，你可以创建一个子文件夹<code>images</code>并将图片存放在此。</li><li><strong>修改Markdown文件中的图片路径</strong>：你需要将Markdown文件中的图片引用改为相对路径。例如，你可以这样更改：</li></ol><p>markdown</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">image-20240308184049708</span>](<span class="hljs-link">/images/image-20240308184049708.png</span>)<br></code></pre></td></tr></table></figure><p>这里的<code>/images/</code>是你在仓库中存放图片的文件夹路径。</p><ol><li><strong>在<code>.gitignore</code>文件中排除本地图片目录</strong>：如果你不希望将所有本地图片都上传到GitHub（例如，某些图片可能太大或不适合公开分享），可以在<code>.gitignore</code>文件中添加规则来排除这些图片。</li><li><strong>使用Git提交和推送</strong>：将更改后的Markdown文件和图片文件夹通过git提交到GitHub上。</li></ol><p>bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;Add images and update markdown paths&quot;</span><br>git push origin main<br></code></pre></td></tr></table></figure><ol><li><strong>配置Hexo</strong>：确保Hexo的配置文件（通常是<code>_config.yml</code>）正确设置了静态文件夹的路径，这样，当Hexo构建站点时，会自动将图片包含在内。</li><li><strong>构建和部署</strong>：最后，在你的本地计算机上运行Hexo的构建命令，通常是<code>hexo generate</code>或<code>hexo g</code>，然后使用部署命令，如<code>hexo deploy</code>或<code>hexo d</code>，将最新的更改部署到GitHub Pages上。</li></ol><p>确保在上传之前检查Markdown文件中所有图片的链接都已经指向仓库中的正确位置。这样，在GitHub Pages构建过程中，相应的图片资源也会被上传，并且当你的博客内容被请求时，图片将能够正确加载显示。</p><h3 id="有没有自动将Markdown文件中的图片引用改为相对路径的方法"><a href="#有没有自动将Markdown文件中的图片引用改为相对路径的方法" class="headerlink" title="有没有自动将Markdown文件中的图片引用改为相对路径的方法"></a>有没有自动将Markdown文件中的图片引用改为相对路径的方法</h3><p>如果你希望自动化这个过程，你可以使用脚本或者现成的工具来批量处理Markdown文件中的图片链接。以下是几种方法：</p><ol><li><strong>使用脚本语言</strong>：编写一个简单的Python或Shell脚本，遍历Markdown文件，查找图片的绝对路径并将其替换为相对于博客仓库的路径。</li><li><strong>使用专用Markdown工具</strong>：一些Markdown编辑器或工具可能提供了批量转换链接的特性。比如，Typora允许你设置图片的复制选项，使得粘贴时自动将图片存放在一个相对路径下。</li><li><strong>使用文本编辑器的查找替换功能</strong>：如果你的文本编辑器支持正则表达式查找替换，你可以使用它来批量更改路径。查找路径格式的正则表达式，然后替换为你的相对路径。</li><li><strong>Hexo插件</strong>：对于Hexo框架，可能存在一些插件能够自动化这个处理过程。需要查找相关的Hexo插件并根据提供的说明进行配置使用。</li><li><strong>版本控制钩子（Git Hooks）</strong>：为你的git仓库设置一个客户端钩子（如pre-commit hook），在你每次提交之前自动运行脚本来修改图片路径。</li></ol><p>每种方法都有其优点和适用场景，你可以根据你的具体需要和熟悉度来选择合适的方法。如果你不熟悉编写脚本，可能需要一些时间来学习与实现。相反，如果你已经习惯了使用某个编辑器或工具，那么查找替换可能是最快的解决方案。</p><h3 id="好的-请你帮我写一个python脚本，遍历Markdown文件，查找图片的绝对路径并将其替换为相对于博客仓库的路径。我的markdown文件放在E-BLOG-source-posts目录下"><a href="#好的-请你帮我写一个python脚本，遍历Markdown文件，查找图片的绝对路径并将其替换为相对于博客仓库的路径。我的markdown文件放在E-BLOG-source-posts目录下" class="headerlink" title="好的 请你帮我写一个python脚本，遍历Markdown文件，查找图片的绝对路径并将其替换为相对于博客仓库的路径。我的markdown文件放在E:\BLOG\source_posts目录下"></a>好的 请你帮我写一个python脚本，遍历Markdown文件，查找图片的绝对路径并将其替换为相对于博客仓库的路径。我的markdown文件放在E:\BLOG\source_posts目录下</h3><p>出现此错误是因为在路径中出现了需要转义的字符，但在替换模式中没有正确转义。在<code>replacement_pattern</code>的字符串中，反斜杠<code>\</code>应该是转义的，而在正则表达式中的反斜杠需要使用双反斜杠<code>\\</code>来表示。</p><p>为了修复这个问题，我们需要对生成的<code>replacement_pattern</code>中的路径进行转义处理。修改后的脚本中将包含对于替换模式中路径的转义代码。尝试以下修正的脚本：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># 配置你的Markdown文件的路径</span><br>markdown_directory = <span class="hljs-string">&#x27;E:\\BLOG\\source\\_posts&#x27;</span><br><span class="hljs-comment"># 配置存放图片的文件夹名称，相对于markdown_directory</span><br>images_directory = <span class="hljs-string">&#x27;images&#x27;</span><br><br><span class="hljs-comment"># 替换绝对路径为相对路径的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">replace_image_path</span>(<span class="hljs-params">file_path, image_dir</span>):<br>    <span class="hljs-comment"># 建立一个正则表达式模式匹配Markdown图片链接</span><br>    regex = <span class="hljs-string">r&#x27;!\[.*?\]\((.*?)\)&#x27;</span><br><br>    <span class="hljs-comment"># 读取Markdown文件内容</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        content = file.read()<br><br>    <span class="hljs-comment"># 使用正则表达式匹配并替换路径</span><br>    new_content = content<br>    matches = re.findall(regex, content)<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">in</span> matches:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">match</span>.startswith(<span class="hljs-string">&#x27;http&#x27;</span>): <span class="hljs-comment"># 只替换本地文件路径</span><br>            new_image_path = os.path.join(<span class="hljs-string">&#x27;/&#x27;</span>, image_dir, os.path.basename(<span class="hljs-keyword">match</span>)).replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>)<br>            new_content = new_content.replace(<span class="hljs-keyword">match</span>, new_image_path)<br><br>    <span class="hljs-comment"># 写回新的内容到文件</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        file.write(new_content)<br><br><span class="hljs-comment"># 遍历目录下所有Markdown(.md)文件</span><br><span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(markdown_directory):<br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>        <span class="hljs-keyword">if</span> file.lower().endswith(<span class="hljs-string">&quot;.md&quot;</span>):<br>            full_path = os.path.join(root, file)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;处理文件：<span class="hljs-subst">&#123;full_path&#125;</span>&#x27;</span>)<br>            replace_image_path(full_path, images_directory)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;所有Markdown文件图片路径更新完毕。&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个修正后的脚本中，我们去除了直接在替换模式中使用反斜杠的情况。此外，我们通过<code>os.path.basename</code>来获取图片文件的基本名称，然后构造了新的相对路径，最后将新路径中的所有反斜杠替换为正斜杠，这样可以保证路径在所有操作系统和网络环境下的通用性。试试看这个更新后的脚本能否正确工作。</p><h3 id="解释一下这一句regex-r’-‘"><a href="#解释一下这一句regex-r’-‘" class="headerlink" title="解释一下这一句regex &#x3D; r’![.?]((.?))‘"></a>解释一下这一句regex &#x3D; r’![.<em>?]((.</em>?))‘</h3><p>这个正则表达式是用来匹配Markdown文档中图片链接格式的。</p><p>让我们逐步分解一下这个正则表达式：</p><ul><li><code>!</code>: 在Markdown中，图片链接是以感叹号<code>!</code>开头的，所以正则表达式首先会查找感叹号。</li><li><code>[`: 紧跟着感叹号的是一个左方括号`[`，在正则表达式中方括号是一个特殊字符，用于定义字符集（character class）。因此，我们需要使用反斜杠</code>来转义它，以匹配文本中的实际方括号。<ul><li><code>.*?</code>: 然后是点号<code>*</code>和问号<code>?</code>的组合。 - 点号<code>.</code>代表任何单个字符（除了换行符）。 - 星号<code>*</code>表示重复前面的字符零次或多次。 - 问号<code>?</code>在这里是一个非贪婪（non-greedy）限定符，它告诉正则表达式引擎匹配尽可能少的字符，直到遇到下一个模式。</li><li><code>\]``: 这部分是查找与前面的左方括号相对应的右方括号</code>]&#96;，同样地，由于方括号在正则表达式中有特殊含义，我们使用反斜杠&#96;&#96;进行转义。</li></ul></li><li><code>\(</code>和<code>\)</code>: 这两个是用来匹配实际的左右圆括号<code>(</code>和<code>)</code>，这两个圆括号用来括起Markdown中图片链接的URL路径，因为在正则表达式中圆括号具有特殊的分组功能，所以需要使用反斜杠<code>\</code>来转义它们。</li><li><code>(.*?)</code>: 这是一个捕获组（capturing group）：<ul><li>括号<code>()</code>定义了一个捕获组，用来捕获和存储匹配的数据以便将来引用。</li><li>点号<code>.*</code>同样表示匹配任何字符零次或多次。</li><li>问号<code>?</code>使得匹配变得非贪婪，即匹配尽量少的字符。</li></ul></li></ul><p>综上所述，正则表达式<code>r&#39;!\[.*?\]\((.*?)\)&#39;</code>整体查找的是一个标记了图片图像且不包含换行符的Markdown链接，它匹配以<code>![]</code>开始，紧跟一个括号内含任意字符（非贪婪匹配）的字符串。括号内的匹配部分（即图片的URL路径）被捕获以便之后使用。</p><hr><p>当你想要重新学习并使用 C++ 来刷力扣（LeetCode）时，以下是一些建议和步骤可以帮助你：</p><h5 id="1-复习基础知识："><a href="#1-复习基础知识：" class="headerlink" title="1. 复习基础知识："></a>1. 复习基础知识：</h5><ul><li><strong>复习语法</strong>：回顾 C++ 的基本语法，如变量、数据类型、运算符、流程控制等。</li><li><strong>STL（标准模板库）</strong>：学习 C++ 标准库中的常用数据结构和算法，如向量（vector）、映射（map）、队列（queue）、堆栈（stack）等。</li></ul><p>相等的时候先放nums1的元素</p><h3 id="vector自动变化大小"><a href="#vector自动变化大小" class="headerlink" title="vector自动变化大小"></a>vector自动变化大小</h3><ol><li><strong>获取数组大小</strong>：使用 <code>size()</code> 成员函数来获取数组的大小（元素个数）。例如，要获取数组的大小，可以使用 <code>nums1.size()</code>。</li><li><strong>插入元素</strong>：使用 <code>push_back()</code> 成员函数将元素添加到数组的末尾。例如，要将新元素 <code>5</code> 插入到数组末尾，可以使用 <code>nums1.push_back(5)</code>。</li><li><strong>删除元素</strong>：使用 <code>pop_back()</code> 成员函数删除数组的最后一个元素。例如，要删除数组的最后一个元素，可以使用 <code>nums1.pop_back()</code>。</li><li><strong>遍历数组</strong>：使用循环结构（如 <code>for</code> 循环）和索引操作符 <code>[]</code> 来遍历数组中的所有元素。例如，可以使用以下代码遍历并打印数组中的所有元素：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    cout &lt;&lt; nums1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sort</code>函数接受两个迭代器作为参数，表示排序范围的起始和结束位置。如果要进行降序排序，可以使用<code>sort(myVector.rbegin(), myVector.rend())</code>，其中<code>rbegin()</code>和<code>rend()</code>表示逆序的起始和结束位置。</p><p>sort(myVector.begin(), myVector.end()); <em>&#x2F;&#x2F; 默认升序排序</em></p><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><p>先将数组 nums2放进数组 nums1的尾部，然后直接对整个数组进行排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            nums1[m+i]=nums2[i];<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(),nums1.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 C++ 中，你不能直接通过 <code>int i = j = p = 0;</code> 这样的方式来同时初始化多个变量，因为 C++ 不支持链式赋值。</p><p>还是一天做一道题吧…</p><h3 id="ctrl-鼠标左键跳入类"><a href="#ctrl-鼠标左键跳入类" class="headerlink" title="ctrl+鼠标左键跳入类"></a>ctrl+鼠标左键跳入类</h3><h3 id="Select-“select-from-employee-where-username-username-”"><a href="#Select-“select-from-employee-where-username-username-”" class="headerlink" title="@Select(“select * from employee where username &#x3D; #{username}”)"></a>@Select(“select * from employee where username &#x3D; #{username}”)</h3><p>看起来你提供的代码片段类似于MyBatis中的SQL查询语句。这段代码使用了MyBatis的注解<code>@Select</code>，并包含了一个查询语句<code>select * from employee where username = #&#123;username&#125;</code>。</p><p>在这个查询语句中，<code>#&#123;username&#125;</code>是一个参数占位符，表示在实际执行查询时会替换为具体的<code>username</code>的值。这种方式可以有效防止SQL注入攻击。</p><p>需要注意的是，<code>@Select</code>注解通常用于在MyBatis的Mapper接口方法上，用于指定对应的SQL查询语句。在实际使用中，你需要确保传入正确的参数值来执行这个查询。</p><h3 id="MyBatis会自动处理参数的转义和过滤，以防止SQL注入攻击。"><a href="#MyBatis会自动处理参数的转义和过滤，以防止SQL注入攻击。" class="headerlink" title="MyBatis会自动处理参数的转义和过滤，以防止SQL注入攻击。"></a>MyBatis会自动处理参数的转义和过滤，以防止SQL注入攻击。</h3><p>它使用预编译语句（Prepared Statement）或命名参数来处理参数，并在执行查询之前自动进行参数值的转义。</p><p>当你在MyBatis的注解语句中使用<code>#&#123;&#125;</code>占位符时，MyBatis会自动将参数进行安全处理。它会确保参数值不会被误解为SQL代码的一部分，并且会对特殊字符进行转义，从而防止注入攻击。</p><p>因此，当使用MyBatis进行数据库查询时，你无需手动编写过滤或转义逻辑来防止SQL注入攻击。但是，仍然需要保证输入的参数值都是可信的，以避免其他类型的安全漏洞。</p><p>在Windows环境下，文件默认是可执行的，所以你不需要像在Unix-like系统中那样修改文件权限。只需确保你的<code>pre-commit</code>钩子脚本的内容是正确的，并且它放置在<code>.git/hooks</code>目录下。</p><h3 id="版本控制钩子（Git-Hooks）是在Git执行特定事件（例如提交和合并）时自动触发脚本的一种机制。对于自动修改图片路径的需求，可以使用pre-commit钩子，在每次提交（commit）之前自动执行一个脚本来更新Markdown文件中的图片路径。"><a href="#版本控制钩子（Git-Hooks）是在Git执行特定事件（例如提交和合并）时自动触发脚本的一种机制。对于自动修改图片路径的需求，可以使用pre-commit钩子，在每次提交（commit）之前自动执行一个脚本来更新Markdown文件中的图片路径。" class="headerlink" title="版本控制钩子（Git Hooks）是在Git执行特定事件（例如提交和合并）时自动触发脚本的一种机制。对于自动修改图片路径的需求，可以使用pre-commit钩子，在每次提交（commit）之前自动执行一个脚本来更新Markdown文件中的图片路径。"></a>版本控制钩子（Git Hooks）是在Git执行特定事件（例如提交和合并）时自动触发脚本的一种机制。对于自动修改图片路径的需求，可以使用<code>pre-commit</code>钩子，在每次提交（commit）之前自动执行一个脚本来更新Markdown文件中的图片路径。</h3><p>以下是使用<code>pre-commit</code>钩子自动更改图片路径的步骤：</p><ol><li><strong>创建钩子脚本</strong>：在你的Git仓库目录中，导航至<code>.git/hooks</code>子目录。如果<code>.git/hooks</code>目录不存在，那可能是你的Git仓库尚未初始化。你可以运行<code>git init</code>来初始化仓库。</li><li><strong>编写钩子</strong>：在<code>.git/hooks</code>目录里，创建一个名为<code>pre-commit</code>的文件（无文件扩展名），并在文件中输入以下脚本内容（假定你的Python脚本文件名为<code>update_image_paths.py</code>并且它位于仓库根目录）：</li></ol><p>sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br><br><span class="hljs-comment"># pre-commit hook to update image paths in Markdown files</span><br>python update_image_paths.py<br><br><span class="hljs-comment"># 如果脚本发现需要更新的内容，则告诉用户提交失败</span><br>git diff --quiet &amp;&amp; git diff --staged --quiet || (<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Image paths updated, please add changes before commit.&quot;</span>; <span class="hljs-built_in">exit</span> 1)<br><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure><ol><li><strong>执行钩子</strong>：在Windows中，直接保存这个文件即可。当你尝试进行git提交时，Git会自动运行该<code>pre-commit</code>钩子脚本。</li></ol><p>如果你的仓库中其他钩子文件都有扩展名（例如<code>.sample</code>），确保你新创建的<code>pre-commit</code>文件没有这样的扩展名。如果你使用的是某些特定的文本编辑器，可能会默认添加扩展名，比如<code>.txt</code>，这时请手动去除。</p><p>一旦钩子脚本创建完成，每当你执行<code>git commit</code>操作之前，<code>pre-commit</code>脚本就会被触发执行。如果<code>pre-commit</code>钩子脚本中的改动导致工作目录存在变化，在提交之前你需要将这些更改添加到暂存区。这一点很重要，因为如果你的Python脚本修改了文件内容，但是没有添加到暂存区，则这些改动不会包含在提交中。</p><h3 id="所以我每次上传博客md文件和图像的话是需要g还是d"><a href="#所以我每次上传博客md文件和图像的话是需要g还是d" class="headerlink" title="所以我每次上传博客md文件和图像的话是需要g还是d"></a>所以我每次上传博客md文件和图像的话是需要g还是d</h3><p>当你上传博客的Markdown文件和图像后，通常你需要先执行<code>hexo generate</code>（或其简写<code>hexo g</code>）来生成最新的静态文件，然后执行<code>hexo deploy</code>（或其简写<code>hexo d</code>）将这些静态文件部署到服务器上。</p><p>具体步骤通常是这样的：</p><ol><li>更新Markdown文件和图像到你的博客项目目录中。</li><li>在命令行中运行<code>hexo g</code>来生成网站的静态内容。这个过程会将你的Markdown和图像文件转换为网页文件，并将它们存放在<code>public</code>目录下。</li><li>完成网站的静态内容生成后，运行<code>hexo d</code>来部署这些内容到指定的服务器上，例如GitHub Pages。</li></ol><p>如果你已经配置了Hexo的一键部署功能，在运行<code>hexo d</code>时，Hexo会自动将<code>public</code>目录中的内容推送到远程仓库，网站即会相应更新。</p><p>请记住，每次对博客内容做出更改，比如添加或编辑文章，或者更改图像等，你都需要运行这两个命令以确保你的更改被应用并展示在你的线上博客中。</p><h3 id="error-cannot-spawn-git-hooks-pre-commit-No-such-file-or-directory-Everything-up-to-date-branch-‘master’-set-up-to-track-‘-x67-x69-x74-x40-103-x69-x74-x68-x75-98-46-99-x6f-x6d-ltspace-ltspace-github-io-git-master’"><a href="#error-cannot-spawn-git-hooks-pre-commit-No-such-file-or-directory-Everything-up-to-date-branch-‘master’-set-up-to-track-‘-x67-x69-x74-x40-103-x69-x74-x68-x75-98-46-99-x6f-x6d-ltspace-ltspace-github-io-git-master’" class="headerlink" title="error: cannot spawn .git&#x2F;hooks&#x2F;pre-commit: No such file or directory Everything up-to-date branch ‘master’ set up to track ‘&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;:ltspace&#x2F;ltspace.github.io.git&#x2F;master’."></a>error: cannot spawn .git&#x2F;hooks&#x2F;pre-commit: No such file or directory Everything up-to-date branch ‘master’ set up to track ‘<a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;</a>:ltspace&#x2F;ltspace.github.io.git&#x2F;master’.</h3><p>这个错误信息表明Git在尝试执行<code>pre-commit</code>钩子时没有找到这个文件，这可能是由于以下几个原因造成的：</p><ol><li><code>pre-commit</code>钩子文件可能没有正确放置在<code>.git/hooks</code>目录中。</li><li><code>pre-commit</code>文件可能没有执行权限（在Windows环境下通常不需要设置执行权限，但有时可能受特定的环境配置影响）。</li><li>如果你使用Windows，并且手动创建了<code>pre-commit</code>文件，可能会不知不觉地给文件加上了默认的<code>.txt</code>等扩展名。</li></ol><p>针对以上情况，请检查以下几点：</p><ul><li>确认<code>pre-commit</code>文件位于正确的目录：<code>.git/hooks</code>。</li><li>确认文件名确实是<code>pre-commit</code>，没有隐藏的扩展名。在Windows文件资源管理器中查看文件名时，要确保设置允许显示已知文件类型的扩展名。</li><li>如果是通过文本编辑器创建的钩子脚本，确保在保存时选择“所有文件”类型，以避免自动添加扩展名。</li><li>尝试直接在命令行中执行<code>pre-commit</code>钩子脚本来看是否能正确运行。如果不能，可能是脚本本身存在问题，或者你的环境中没有安装Python或者脚本的执行路径不对（在脚本的开头<code>#!/bin/sh</code>可能需要指向正确的shell路径，这在Windows中通常不是必须的，但是依赖于你的环境配置）。</li></ul><p>如果上述都没问题，你可以尝试删除<code>pre-commit</code>钩子并重新创建它。如果错误仍然存在，那么需要对你的Git安装和配置环境做更深入的查看。在极端情况下，你可能需要重新安装Git或者调查是否有其它系统级的问题影响到了Git钩子的执行。</p><h3 id="我的git仓库里-git的名字是-deploy-git，是这个的原因吗"><a href="#我的git仓库里-git的名字是-deploy-git，是这个的原因吗" class="headerlink" title="我的git仓库里.git的名字是.deploy_git，是这个的原因吗"></a>我的git仓库里.git的名字是.deploy_git，是这个的原因吗</h3><p>如果你的 <code>.git</code> 文件夹的名字被改为了 <code>.deploy_git</code>，那很有可能是使用了Hexo的部署机制，特别是当采用<code>hexo-deployer-git</code>插件时，它会创建一个<code>.deploy_git</code>目录用来作为Git部署仓库。这个目录用于存储生成的静态文件，并将其推送到远程仓库，比如GitHub Pages。</p><p><code>.deploy_git</code>目录与你本地编辑文档的Git仓库（通常用<code>.git</code>目录来管理）是分开的。Git钩子需要放在实际的Git仓库的<code>.git/hooks</code>目录中。如果你将钩子脚本放到了<code>.deploy_git</code>目录，那么它不会在你的常规Git操作中被触发。</p><p>解决方法如下：</p><ol><li>确认你的本地仓库（包含你编辑的源文件）的<code>.git</code>目录。它应该是你项目根目录的<code>.git</code>文件夹，而不是Hexo生成的<code>.deploy_git</code>文件夹。</li><li>将你的<code>pre-commit</code>钩子脚本放入你项目根目录下的<code>.git/hooks</code>目录中。</li><li>确保<code>pre-commit</code>钩子脚本具有正确的内容，并且能够在你尝试提交到你的源代码仓库时被触发。</li></ol><p>如果你尝试修改你的源代码并提交（例如使用<code>git commit</code>命令），那么钩子脚本应该在你项目的<code>.git/hooks</code>目录中被触发。如果你仅仅使用<code>hexo deploy</code>命令部署网站，它是不会触发这个钩子的，因为这通常会直接向<code>.deploy_git</code>仓库提交。</p><h3 id="不对，我发现我的-depoly-git里还有一个-git文件夹-这个文件夹又是干什么的"><a href="#不对，我发现我的-depoly-git里还有一个-git文件夹-这个文件夹又是干什么的" class="headerlink" title="不对，我发现我的.depoly_git里还有一个.git文件夹 这个文件夹又是干什么的"></a>不对，我发现我的.depoly_git里还有一个.git文件夹 这个文件夹又是干什么的</h3><p>在Hexo项目中，<code>.deploy_git</code>文件夹是用于存储Hexo生成的静态文件以便部署到远程服务器的地方。当你使用<code>hexo-deployer-git</code>插件进行部署时，Hexo会将<code>public</code>目录中生成的静态文件复制到<code>.deploy_git</code>目录，并在该目录初始化一个新的Git仓库用于部署。</p><p><code>.deploy_git</code>目录中的<code>.git</code>文件夹是这个用于部署的Git仓库的元数据存储位置，其中包含了版本控制的相关信息，如分支、提交历史、配置等。实际上，<code>.deploy_git</code>目录本身就像是一个完整的Git仓库。</p><p>当你执行<code>hexo deploy</code>命令时，以下步骤会被触发：</p><ol><li>Hexo调用<code>hexo generate</code>生成静态文件。</li><li>生成的静态文件被复制到<code>.deploy_git</code>目录。</li><li>在<code>.deploy_git</code>目录执行Git命令，将变更添加(commit)到本地仓库，并将其推送(push)到远程服务器（如GitHub Pages或其他托管服务）。</li></ol><p><code>.git</code>文件夹在<code>.deploy_git</code>目录中的作用是管理这一部署过程中所有的Git操作和历史记录。</p><p>如果你在尝试运行Git钩子时遇到问题，请确保钩子被放置于你的源代码仓库的<code>.git/hooks</code>目录中，而不是<code>.deploy_git</code>目录或其内的<code>.git</code>目录中。这样，当你操作源代码仓库时（比如执行<code>git commit</code>），钩子才会被正确触发。</p><p><img src="C:\Users\14097\AppData\Roaming\Typora\typora-user-images\image-20240309112717007.png" alt="image-20240309112717007"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习日寄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DAY2日寄-苍穹外卖01-毕设电子-java八股</title>
    <link href="/2024/03/08/DAY2/"/>
    <url>/2024/03/08/DAY2/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/image-20240308094713778.png" alt="image-20240308094713778"></p><p><img src="/images/image-20240308094749852.png" alt="image-20240308094749852"></p><p><img src="/images/image-20240308095429320.png" alt="image-20240308095429320"></p><p><img src="/images/image-20240308100445990.png" alt="image-20240308100445990"></p><p><img src="/images/image-20240308102810152.png" alt="image-20240308102810152"></p><p><img src="/images/image-20240308103740063.png" alt="image-20240308103740063"></p><p>我他妈在acwing花了两千块钱了</p><p><img src="/images/image-20240308104638739.png" alt="image-20240308104638739"></p><p>双击nginx项目的nginx.exe就能启动，路径不能带中文，localhost，端口默认80不用输入</p><h3 id="万用表交流测的是峰峰，所以电压会达到六百多伏"><a href="#万用表交流测的是峰峰，所以电压会达到六百多伏" class="headerlink" title="万用表交流测的是峰峰，所以电压会达到六百多伏"></a>万用表交流测的是峰峰，所以电压会达到六百多伏</h3><p><a href="https://www.bilibili.com/video/BV1Mc411o7gN?p=3&vd_source=e404ad14246992bcc3e4ac52a33df8ed">（基础）基本电路知识_哔哩哔哩_bilibili</a></p><p>DTO data transfer object 数据传输对象，各层传输数据</p><p>VO view object 视图对象，前端展示</p><p>POJO 只有属性和getter和setter</p><p>Entity 实体，对应数据库表</p><h3 id="idea等连接github的代理设置"><a href="#idea等连接github的代理设置" class="headerlink" title="idea等连接github的代理设置"></a>idea等连接github的代理设置</h3><p>对windows用户来说，只需要在命令行执行如下命令即可。这样就可以通过代理访问github了。</p><p>如果是http代理：</p><p>git config –global http.<a href="https://github.com.proxy/">https://github.com.proxy</a> <a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a></p><p>&#x2F;&#x2F;如果是sock代理<br>git config –global http.<a href="https://github.com.proxy/">https://github.com.proxy</a> socks5:&#x2F;&#x2F;127.0.0.1:1080</p><p><img src="/images/image-20240308161233439.png" alt="image-20240308161233439"></p><p><a href="https://blog.csdn.net/weixin_45959563/article/details/120295759">idea报错解决办法：Error executing Maven. The specified user settings file does not exist: C:\Users\Gmx.m2-CSDN博客</a></p><p><img src="/images/image-20240308161746203.png" alt="image-20240308161746203"></p><p><img src="/images/image-20240308162617063.png" alt="image-20240308162615780"></p><p>application.yml里改了端口号，8080和8090都在被占用，但netstat发现没被占用，最后改成42220就行了  奇怪</p><p>mysql命令</p><p><img src="/images/image-20240308163604573.png" alt="image-20240308163604573"></p><p>ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES)</p><p><img src="/images/image-20240308164001405.png" alt="image-20240308164001405"></p><p>要用管理员shell运行mysql的启动停止命令，mysql的名称是mysql80，不分大小写</p><h3 id="mysql服务的启动和停止"><a href="#mysql服务的启动和停止" class="headerlink" title="mysql服务的启动和停止"></a>mysql服务的启动和停止</h3><p>net start mysql80</p><p>记得有80（在win+r的service.msc里看的服务名）</p><p><a href="https://blog.csdn.net/weixin_40873693/article/details/113056113">执行sc query mysql，sc delete mysql没有反应_sc delete mysql80没有反应-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_42785280/article/details/97255637">MySQL：net start MySQL80：发生系统错误 5。拒绝访问。_net start mysql80 发生系统错误 5。 拒绝访问。-CSDN博客</a></p><p><a href="https://blog.csdn.net/hkdhkdhkd/article/details/121158926">Mysql忘记登录密码的解决步骤（完整步骤）_mysql密码忘了怎么办-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_40845165/article/details/100943054">ERROR 1054 (42S22): Unknown column ‘password’ in ‘field list’-CSDN博客</a></p><p><img src="/images/image-20240303092609821.png" alt="image-20240303092609821"></p><p><img src="/images/image-20240303092857419.png" alt="image-20240303092857419"></p><p>重装了一遍mysql，密码改成了0000</p><h3 id="我在idea里改了几个参数，再重新运行项目的时候还需要重新maven构建吗"><a href="#我在idea里改了几个参数，再重新运行项目的时候还需要重新maven构建吗" class="headerlink" title="我在idea里改了几个参数，再重新运行项目的时候还需要重新maven构建吗"></a>我在idea里改了几个参数，再重新运行项目的时候还需要重新maven构建吗</h3><p>一般来说，如果你在IDEA中改变了项目中的参数，并且这些参数是在构建过程中被使用到的（例如pom.xml中的配置参数），那么重新进行Maven构建可能是必要的，以确保这些变化被正确应用。如果是改变了代码中的参数，而这些参数不影响项目的依赖关系或构建过程，通常仅需要重新编译改动的部分即可。不过进行完整构建可以确保一切都是最新的，避免某些情况下因为环境的不同步导致的问题。</p><h3 id="启动流程："><a href="#启动流程：" class="headerlink" title="启动流程："></a>启动流程：</h3><p>1前端nginx文件夹双击</p><p>2 mysql启动（mysql -u root -p）</p><p>3 idea，skyserver，skyapplication类启动</p><p>注意点：</p><p>application-dev.yml改mysql的密码的时候，纯数字要加单引号</p><h3 id="nginx配置文件里的这一段中，weight是干什么用的"><a href="#nginx配置文件里的这一段中，weight是干什么用的" class="headerlink" title="nginx配置文件里的这一段中，weight是干什么用的"></a>nginx配置文件里的这一段中，weight是干什么用的</h3><p>upstream webservers{   server 127.0.0.1:8080 weight&#x3D;90 ;   #server 127.0.0.1:8088 weight&#x3D;10 ; }</p><p>在Nginx配置文件的<code>upstream</code>模块中，<code>weight</code>参数用于定义负载均衡时各服务器的权重比例。在你这个<code>upstream</code>块中，使用了<code>weight</code>参数来分配请求到不同服务器的相对比例。</p><ul><li><code>server 127.0.0.1:8080 weight=90;</code> 表明第一个服务器（在这里是本机的8080端口上的服务器）的权重是90。</li><li><code>#server 127.0.0.1:8088 weight=10;</code> 这一行已被注释掉，但如果取消注释，它将表明第二个服务器（在这里是本机的8088端口上的服务器）的权重是10。</li></ul><p>当有一个请求到达<code>upstream</code>定义的服务器组时，Nginx会按照权重来决定将请求发送到哪个服务器。在这个例子中，如果第二行没有被注释掉，那么理论上每有100个请求，大约90个会被发送到端口8080上的服务器，而大约10个请求会被发送到端口8088的服务器。</p><p>使用权重可以使得流量分配更加灵活，特别是当服务器的处理能力不相同时，可以通过调整权重来分配更多的请求到性能更强的服务器上。</p><h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><p><img src="/images/image-20240308183647122.png" alt="image-20240308183647122"></p><p>ctrl+alt+B，跳转到方法.</p><p><img src="/images/image-20240308184049708.png" alt="image-20240308184049708"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习日寄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DAY1日寄-主修毕设电路原理图绘制</title>
    <link href="/2024/03/08/DAY1/"/>
    <url>/2024/03/08/DAY1/</url>
    
    <content type="html"><![CDATA[<h2 id="DAY1日寄-主修毕设电路原理图绘制"><a href="#DAY1日寄-主修毕设电路原理图绘制" class="headerlink" title="DAY1日寄 主修毕设电路原理图绘制"></a>DAY1日寄 主修毕设电路原理图绘制</h2><p>常见暖气片漏水部位：</p><p>由于工艺的原因，暖气片片头与柱体是焊接在一起的，并不是一个整体，焊点处最容易被腐蚀。</p><p>毕设要做基于esp8266的暖气片漏水检测系统，要自己画电路板，<br>温湿度检测，要知道暖气片口径的尺寸<br>内径为20mm，外径约为25mm</p><p>流量传感器的数据需要有自学习的过程，一段时间后应该有最优的数值，esp8266传到手机端的报警信号，手机端可发送控制命令关闭暖气的阀门，理论上不是很难，但细节要详细设计，包括pcb板都要设计好。</p><p>stm32最小系统板？√</p><p>esp8266√</p><p>oled屏幕√</p><p>mos管控制电磁阀√ </p><p>有源蜂鸣器√</p><p>流量传感器（已经下单）</p><p>AC交流，DC直流</p><p>S8050三极管驱动继电器，继电器控制电磁阀</p><p>0欧姆电阻？</p><p><img src="/images/image-20240307112316088.png" alt="image-20240307112316088"></p><p><img src="/images/image-20240307180836061.png" alt="image-20240307180836061"></p><p>我现在在画基于stm32的pcb板，我先从网上下载了stm32最小系统板的原理图，再自己添加上esp8266等模块，但是我有个问题，就是我下载的stm32最小系统板的原理图里，stm32的可用引脚都通过排针外扩了，我如果把已经外扩了的引脚也连到我添加的esp8266模块上会发生什么，这么做是对的吗，我能在外扩的同时也连接模块吗</p><p>没问题的，其实这样的设计在PCB板设计中很常见。STM32的可用引脚通过排针外扩，是为了能够便捷地连接到其他电路或测试设备。至于你想要将这些引脚同时连到ESP8266模块上，完全是可以的，前提是你需要确保以下几点：</p><ol><li>电气连接正确：确保STM32的引脚与ESP8266模块的对应引脚电气特性兼容，没有冲突。比如说，不要把供电引脚错误地连接到地引脚或信号引脚。</li><li>信号干扰问题：当一个引脚连接多个模块时，可能会引入信号干扰。你需要设计合适的走线和地平面, 并在必要时添加适当的滤波和隔离元件。</li><li>I&#x2F;O负载：确保STM32的I&#x2F;O引脚没有超出其承受的驱动能力。每个I&#x2F;O引脚都能提供一定的电流，你要检查所有连接到该引脚的模块总共需要的电流是否超出了STM32引脚的最大输出电流。</li><li>软件管理：在软件层面，你需要正确地配置STM32的I&#x2F;O引脚，避免在程序中造成引脚状态的冲突。</li></ol><p>只要你能够处理好上述提到的几个方面，你就可以在外扩的同时也连接模块。当然，进行这样的设计之前，最好还是好好规划一下，确保整个系统的稳定性和可靠性。开工前做好设计和规划，事半功倍喔</p><p>当你将STM32的一个单独引脚同时连接到外扩引脚和另一个模块（比如ESP8266）时，在软件编程方面需要考虑到以下几点：</p><ol><li><strong>引脚功能冲突</strong>：确保在同一时刻，这个引脚不会被外扩接口和ESP8266同时要求执行不同的功能。你需要设计你的程序逻辑来避免这种冲突，比如通过状态机来管理这个引脚的状态。</li><li><strong>引脚方向设置</strong>：程序中需要设置GPIO的输入&#x2F;输出方向。如果引脚被配置为输出，STM32将能够向ESP8266发送信号；如果配置为输入，STM32将能够接受来自ESP8266的信号。如果同一时刻既想读信号也想写信号，就需要编写控制代码来临时切换引脚状态。</li><li><strong>互斥访问</strong>：如果某一时刻只允许外扩引脚或者ESP8266中的一个与STM32的引脚进行通信，你需要确保程序中通过某种互斥机制来管理这种通信的访问。可以通过软件标志位来确定哪个模块可以使用该引脚。</li></ol><p>举个例子: 假设有一个引脚PA0，你同时连接到了外扩接口和ESP8266。那么你的程序可能会这样控制：</p><p>c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 检测ESP8266模块是否需要通信</span><br><span class="hljs-keyword">if</span> (ESP8266_needs_communication) &#123;<br>    <span class="hljs-comment">// 配置PA0为通信所需的模式</span><br>    GPIO_InitStruct.Pin = GPIO_PIN_0;<br>    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; <span class="hljs-comment">// 假设为特定的替代功能</span><br>    GPIO_InitStruct.Pull = GPIO_NOPULL;<br>    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);<br>    <br>    <span class="hljs-comment">// 与ESP8266模块进行数据交换</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 如果外扩接口需要使用PA0</span><br><span class="hljs-keyword">if</span> (extension_needs_communication) &#123;<br>    <span class="hljs-comment">// 配置PA0为外扩接口所需的模式</span><br>    GPIO_InitStruct.Pin = GPIO_PIN_0;<br>    GPIO_InitStruct.Mode = GPIO_MODE_INPUT; <span class="hljs-comment">// 假设外扩为输入模式</span><br>    GPIO_InitStruct.Pull = GPIO_PULLUP;<br>    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);<br><br>    <span class="hljs-comment">// 与外扩接口进行数据交换</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在实际应用中，你可能还需要加入一些延时或者中断，以确保STM32可以正确地处理来自不同源的信号。还有很多优雅的处理方式，上面的代码只是一个简单的示例。</p><p>记住，当你设计这样的复用引脚时，一定要确保不会引起电气层面的冲突，并且确保在任何时刻引脚状态的改变都是在你的控制之下，不会不经意间发生。</p><p><img src="/images/image-20240307185323901.png" alt="image-20240307185323901"></p><p><img src="/images/image-20240307185338961.png" alt="image-20240307185338961"></p><p>当然可以，ESP8266-12F是一个非常受欢迎的WiFi模块，具有紧凑的尺寸和低功耗，非常适合物联网(IoT)项目。以下是常见的几个原理图连接点的解释：</p><ol><li><strong>天线</strong>: ESP8266-12F包含一个PCB板天线，且通常不需要外加天线。这是连接到无线网络的关键部分。</li><li><strong>电源</strong>：ESP8266-12F需要一个稳定的3.3V电源，供电电压不能高于3.6V。可能还会看到一个电源旁有去耦电容以稳定电源，并避免因为供电波动造成运行时的不稳定。</li><li><strong>GPIO</strong>：这些引脚为通用输入输出端口，用来连接传感器、执行器或其他模块。</li><li><strong>串行通信引脚（RX&#x2F;TX）</strong>：这些用于与ESP8266交流数据，如用于编程固件或和其他设备的通信。</li><li>**CH_PD(Chip Enable)**引脚需要连接到VCC来激活芯片；</li><li><strong>RESET</strong>：复位引脚可用于重启模块。</li><li><strong>GPIO15, GPIO0, GPIO2</strong>和<strong>EN（Enable）</strong>引脚通常会有特定的上拉或下拉电阻，以确保ESP8266在启动时能进入正确的启动模式。比如：<ul><li><strong>GPIO15</strong>需要接地（带下拉电阻）。</li><li><strong>GPIO0</strong>决定了模块是进入编程模式还是正常启动，通常通过上拉来正常启动。</li><li><strong>GPIO2</strong>也需要上拉。</li></ul></li><li><strong>去耦电容</strong>：在电源线和地之间接去耦电容非常重要，这有助于滤除电源中的噪声，使模块运行更加稳定。</li></ol><p>每个电路设计都有其特定目的和电气特性的考量。设计者在手册或数据表的指导下进行设计，以确保模块稳定工作并遵守电气规范。如果你有特定的设计方面的问题或者需要详细的电路解释，提供更多的上下文将有助于给出更精确的解答。希望这些信息对你的项目有帮助！🛠️📡</p><p>要将 ESP8266-12F WiFi 模块与 STM32F103C8T6 微控制器连接并控制它，你可以按照以下简单步骤操作：</p><ol><li><strong>供电</strong>：<ul><li>ESP8266 需要 3.3V 的电源，这意味着你可以直接从 STM32 板上的 3.3V 引脚供电给 ESP8266。</li><li>确保你的电源能够提供足够的电流，因为 ESP8266 在启动或通信时可能会短暂消耗较高功率。</li></ul></li><li><strong>串行通信</strong>：<ul><li>将 ESP8266 的 TX（发送）引脚连接到 STM32F103C8T6 的某个 UART 接收（RX）引脚上。</li><li>将 ESP8266 的 RX（接收）引脚连接到 STM32F103C8T6 的某个 UART 发送（TX）引脚上。</li><li>选择合适的 GPIO 引脚分配给 UART 接口，并在 STM32 软件中适当配置。</li></ul></li><li><strong>编程与控制</strong>：<ul><li>使用 STM32 的 UART 接口，通过发送 AT 指令来控制 ESP8266。这些指令用于设置网络连接、发送数据等。</li><li>根据你的需要，可能要编写或使用一个串口库来管理 UART 通讯。</li></ul></li><li><strong>GPIO 互连</strong>（可选）：<ul><li>如果你需要更精细的控制，如重置 ESP8266 或监控其状态，你也可以将 ESP8266 的 GPIO 引脚（如 CH_PD 或 RESET）连接到 STM32 的 GPIO 引脚，并通过软件控制它们。</li></ul></li><li><strong>软件配置</strong>：<ul><li>在 STM32 中设置 UART 接口的波特率，确保它与 ESP8266 的设置相匹配。</li><li>实现或使用一个库来发送 AT 指令并解析响应。</li><li>创建一个循环来维护 WiFi 连接，处理网络通信任务。</li></ul></li></ol><p>下面是一个示例连接图：</p><table><thead><tr><th>ESP8266</th><th>STM32F103C8T6</th></tr></thead><tbody><tr><td>VCC</td><td>3.3V</td></tr><tr><td>GND</td><td>GND</td></tr><tr><td>TX</td><td>PA10 (RX)</td></tr><tr><td>RX</td><td>PA9 (TX)</td></tr><tr><td>CH_PD</td><td>3.3V (通常与 VCC 连接)</td></tr><tr><td>RESET</td><td>(可选连接至 STM32 GPIO)</td></tr></tbody></table><p>在编写代码来控制 ESP8266 之前，请确保你已经通过 USB-to-Serial 转换器或类似的东西更新了 ESP8266 的固件，并且能够理解和使用 AT 指令集。</p><p>请牢记：</p><ul><li>在连接之前，请双检查所有的引脚配置，以避免任何硬件损坏。</li><li>焊接 ESP8266-12F 模块通常比较困难，因为它是一个带有金属盖的小型 SMD 模块。小心操作，以免烧坏模块或相关的电路。</li></ul><p>要通过I2C接口连接STM32F103C8T6（以下简称STM32）与HS96L03 OLED显示模块（以下简称OLED），您需要按照以下步骤操作：</p><ol><li><strong>电源连接</strong>：<ul><li>将STM32的VCC引脚连接到OLED模块的VCC，提供所需电压（通常为3.3V或5V，需根据规格书确定）。</li><li>将STM32的GND引脚连接到OLED模块的GND，形成共同的地线。</li></ul></li><li><strong>I2C数据线连接</strong>：<ul><li>将STM32的I2C_SDA引脚连接到OLED模块的SDA引脚。</li><li>将STM32的I2C_SCL引脚连接到OLED模块的SCL引脚。</li></ul></li><li><strong>外接上拉电阻</strong>：<ul><li>在SDA和SCL线路上，分别外接上拉电阻到VCC。通常电阻值可以选择在4.7kΩ到10kΩ之间，具体值需要根据系统的I2C总线长度以及所用OLED模块的电气特性来决定。</li></ul></li><li><strong>配置STM32</strong>：<ul><li>在STM32的固件中配置I2C接口，包括初始化I2C时钟速率、地址模式和所使用的I2C端口等。</li><li>如果OLED模块有特定的初始化序列，也需要按照规格书中的要求，在STM32固件中加入相应的初始化代码。</li></ul></li><li><strong>编写显示代码</strong>：<ul><li>开发相应的软件来驱动OLED，并实现所需的显示功能，比如显示文本、图像等。</li></ul></li><li><strong>实际测试</strong>：<ul><li>在接线完成后，上传固件并对连接进行测试，以确保I2C通信正常工作且OLED可以正确显示。</li></ul></li></ol><p>在进行连接前，请确保参考STM32以及OLED的规格书来获取精确的接线信息及电气参数，防止因误接线而损坏设备。此外，在连接OLED之前，请先通过STM32的数据手册验证其的I2C引脚位置，因为不同的STM32模型其I2C引脚配置可能会有所不同。如果一切按照上述步骤进行并且规格都符合要求，那么I2C接口的连接应该就能够实现功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习日寄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24考研的具体经验反思</title>
    <link href="/2024/03/02/24%E8%80%83%E7%A0%94%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%8F%E9%AA%8C%E5%8F%8D%E6%80%9D/"/>
    <url>/2024/03/02/24%E8%80%83%E7%A0%94%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%8F%E9%AA%8C%E5%8F%8D%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="24考研的具体经验反思"><a href="#24考研的具体经验反思" class="headerlink" title="24考研的具体经验反思"></a>24考研的具体经验反思</h1><p>（未完成）</p><hr><p>我觉得github上有个仓库极其的好，叫《考研：有手就行》</p><p>这位大哥是二战的，22年分数一般，但23年上岸上交计算机，水平真不是一般人，</p><blockquote><ul><li>第一次的初试分数是79 + 72 + 93 + 86 &#x3D; 330（11408），未进复试。</li><li>第二次的初试分数是80 + 75 + 137 + 122 &#x3D; 414（11408），复试分数是180分（总分200）。</li></ul></blockquote><p>我今年是64 + 79 + 97 + 100 &#x3D; 340（11408），</p><p>鉴于我这北京和他那上海都挺旱的，只能说我俩一战水平差不多。</p><hr><p>他给出了无比具体且可量化的方法，</p><p>趁现在还早，你如果严格按照他的方式来，是真的可以考个巨无敌高的分数。</p><p>（额也说不定，万一明年题更难了，超纲题更多了，这种情况看谁都没用）</p><p>我当时看到的时候已经晚了。</p><hr><p>记得这个库还是后台一粉丝介绍给我的，说我和那个大佬理念很相似，</p><p>经过这一切之后再想起这个评价，真是太讽刺了。</p><hr><p>我其实不想由果索因，因为会额外否定很多东西。</p><p>但没有结果的时候，又会不自觉美化自己的行为。</p><hr><p>个人情况：</p><p>山东高考，末流985，计算机本科，一战北京11408，笨拙的努力型选手。</p><hr><h2 id="1-政治"><a href="#1-政治" class="headerlink" title="1 政治"></a>1 政治</h2><p>客观39，主观25，总分64.</p><p>简单来说，还是别花时间学政治了。</p><hr><h3 id="1-1-选择"><a href="#1-1-选择" class="headerlink" title="1.1 选择"></a>1.1 选择</h3><p>我后期买了那个喵刷政治的微信小程序，也买了苍盾政治的小程序，</p><p>比较之后用喵刷，UI简洁舒适，能归类错题生成pdf打印纸质版，</p><p>最重要的是能长按排除选项，对于选择题来说很有用。</p><p>对了，我提到的都不是广，没有人会找我这种没粉丝的公众号投广告。</p><hr><p>然后用喵刷刷了几乎所有的模拟卷的选择；肖八肖四选择题二刷三刷、纸质版刷完小程序刷；错题归档，打印纸质版继续二刷三刷。</p><p>背腿姐手册，背b站帕拉迪宇的一页纸，用政治带背下饭，</p><p>最后选择39，错仨单选，四多选。</p><p>挺烂，我记得今年出来之后很多人说政治选择简单。</p><hr><p>政治选择方面应该很少人能超过我花费的时间。</p><p>你看，这可怜的投入产出比，（笑）。</p><p>不过我记得肖八刚出来的时候我第一套选择19分，大家平均也在一二十分左右，</p><p>该看的还是得看看，才能上40，</p><p>我意思就是该刷的刷，别刷多了。</p><p>十二月只刷肖八肖四吧各位，刷多了也没用。</p><p>反正大家水平都差不多之后，主要还是看运气。</p><hr><p>平常互联网键政的各位，尤其是魔怔人，</p><p>我建议你们前期也不用买核心考案听徐涛的课了，很多概念你们都懂，</p><p>不懂的东西到十一二月的时候对着背诵手册细品一下也就明白了，很多都是你们平常唠的东西。</p><hr><h3 id="1-2-大题"><a href="#1-2-大题" class="headerlink" title="1.2 大题"></a>1.2 大题</h3><p>我这可怜的25分，我分析的是，</p><ul><li>京区主观狠压分</li><li>字体巨无敌烂</li><li>套张修齐模板抄材料少</li></ul><hr><p>我现在挺后悔的，每天挂嘴边的就是京区把我害惨了，</p><p>放别的水区政英高二十分，调剂得多好调，</p><p>这就是当时不考虑退路的下场。</p><hr><p>字体巨无敌烂这一点我也没想到，我没想到威海职业学院那几天那么冷，</p><p>前一天刚下完持续几周的雪，后一天就开始考试，化雪的同时考场还是没暖气的阶梯教室，</p><hr><p>备考的时候要不还是找找适合你考场的温度吧，</p><p>像我，所有备考的时间为了不让身体状态影响我，都选择的是冬暖夏凉的图书馆，</p><p>导致我在20℃图书馆里模拟的政治字体间距排版等等一切，在零下的考场上全部失效。</p><hr><p>买了四五十个暖宝宝，那两天全用完了，到处都贴，只能管前一小时，手还是冻僵握不住笔。</p><p>写的时候很难受，</p><p>我因为背的张修齐，每道题能写上的东西极其的多，我不想放过任何一个得分点，就把每一个答题空都写上了密密麻麻的蝇头小字，最后看我的答题卡，可以算是乌黑一片，</p><p>手冻僵了完全控制不了，同时肾上腺素作用，我边发抖边写字，这种情况下也没办法控制字体。</p><p>最后就是这个结果。</p><hr><p>最后一点，</p><p>我觉得张修齐老师确实很好，直播点拨的答题思路经常让人恍然大悟，</p><p>娱乐性也强，懂得都懂，</p><p>十页纸也很好用，覆盖考研大题，减少了绝大部分背诵负担。</p><p>考水区的可以放心跟张修齐老师。</p><p>考旱区的话，我建议是肖八肖四也得看看，结合材料，自己组织语言和答分点，简洁清晰的卷面更重要。</p><hr><p>还是那句话，你到十一二月再开政治完全不迟。</p><hr><p><img src="/images/image-20240302191735961.png" alt="image-20240302191735961"></p><h2 id="2-英语"><a href="#2-英语" class="headerlink" title="2.英语"></a>2.英语</h2><p>完型全对，阅读错仨，主观小作文6.5&#x2F;10，大作文11&#x2F;20，翻译7&#x2F;10，只能说难评，京区就这样。</p><hr><h3 id="2-1-客观"><a href="#2-1-客观" class="headerlink" title="2.1 客观"></a>2.1 客观</h3><p>四六级裸考均分580，属于英语没那么好，但也不用额外补的水平。</p><p>单词没背完，太多了，红宝书那么一厚本我是真难绷，不背单词显示有六千多个？</p><p>我寻思着光单单在软件上按完就得花我一辈子。</p><hr><p>后来只在不背单词上随便选了一个只有七八百的考研核心词的词书，</p><p>也没背完，最后剩了二百多个。</p><p>我的经验是还是得三人组队，找俩比较好的朋友，互相监督，不然我根本没时间打开软件。</p><p>当时主要背单词的时间都是在组队的那一个月背的，每天背十五分钟打卡，打完立马关了。</p><hr><p>真题大概做了不到十套，</p><p>十月份的时候先做的10、11年的，当时完型动辄错11、12个，气笑了，就没再管，因为知道那段年份难。</p><p>后来十一月有空的时候做了几套近几年的选择，觉得阳间了不少，</p><p>完型稳定在两三个，阅读稳定在三四个，</p><p>当时实在是没时间，寻思着既然这水平能用了，就这样得了。</p><p>所以最后考试前那一个月也没做一两套英语，全吃老本。</p><hr><p>最后证明运气还行，考场上的文章都能看懂，花二十分钟做完了客观题。</p><hr><h3 id="2-2-主观"><a href="#2-2-主观" class="headerlink" title="2.2 主观"></a>2.2 主观</h3><hr><p>大作文用的红果研王晶婷的作文书，实在是很好用，</p><p>像拼图一样，可以选用不同水平的句子拼凑出属于自己的模板，</p><p>但主要还是靠当场发挥。</p><hr><p>小作文搁十二月份背背那几个信件类型开头结尾的句式就行，</p><p>我感觉考研从我这届开始变得变化莫测了，试图考前压中题目是极其吃力不讨好的事儿，</p><p>中间的部分还不如当场发挥。</p><hr><p>十一二月开始，大小作文分别模了两三次吧，平常就背背自己攒的模板。</p><hr><p>翻译没啥说的，感觉无论翻译的再好在北京都会每道题扣0.5。</p><hr><p>小作文写跑题了，</p><p>人外国人说要做一个ancient scientist的讲座，关于古代中国科学家的讲座，</p><p>按理说应该推荐中国古代的科学家，所以舍友问我写的谁的时候我汗流浃背，</p><p>我看成是面向研究中国古代文明的科学家做中文讲座，</p><p>写让他去bilibili学汉语，让他别担心，中国人都挺友善，你发音不准也不会嘲笑你，</p><p>跑题了还有6.5，可能把批试卷的研究生逗乐了。</p><hr><p>大作文也挺逗，</p><p>各路老师考前预测，还是如同一成不变的往年，英一还是看图写话类作文，英语二还是图表类作文，</p><p>然后今年发下试卷来，我看了一眼大作文，</p><p>嘿，图片和图表都有，又给我气笑了。</p><p>图片好像是一座公园，游人自得其乐，图表是公园数量逐年上涨。</p><p>凭着仅有的对于图表趋势性描述的记忆简单写了几句。</p><p>后来就是赞颂Party好，government好，人民生活幸福感高，经济稳中向好。</p><p>不然还能说什么呢。</p><hr><p>总之英语我几乎没花时间，对我来说是性价比爆棚的学科，</p><p>这大概就是那些大佬学数学的感受。</p><hr><p><img src="/images/image-20240302202850572.png" alt="image-20240302202850572"></p><hr><h2 id="3-数学"><a href="#3-数学" class="headerlink" title="3 数学"></a>3 数学</h2><p>这个部分，我都痛苦的不想回忆它。</p><p><img src="/images/image-20240302212124335.png" alt="image-20240302212124335"></p><hr><p>选择错仨，填空错仨，30分就已经没了。</p><p>极其恐怖。</p><p>我最后还能考97，全靠大题判卷放水。</p><hr><p>所以那个上交佬在数学篇的一开始就说，</p><blockquote><p>数学是一门方差极大的学科，这个方差既指考生之间的方差，又指考生（发挥）的方差。</p></blockquote><p>我觉得能考到145-150的人，最低也就140，这只是试卷的上限，不是他深厚积累的底线。</p><p>但是在120，110，100分数段的人，完全可以考到90。</p><hr><p>太痛苦了，是想想就想死的程度。</p><p>如果我备考有100%的时间，</p><p>那么60%的时间都在学数学，</p><p>30%的时间学408四门课，</p><p>8%的时间学政治，</p><p>2%的时间学英语。</p><hr><p>性价比低到了一个令人咋舌的程度，感觉我学一两个月和我学一年相比，分差也不会超过20。</p><hr><p>基础和强化全程跟的张宇，</p><p>我觉得没必要一听别人说张宇的课门槛高就退缩，我这种大学高数60分的人都能正常听懂，门槛高又能高到哪儿去呢。</p><p>线代大后期又跟了b站的帕拉迪宇，小铜数学等一系列优秀up主，</p><p>反正他们互相认识也合作过视频，找到一个就可以顺藤摸瓜找到其他人。</p><p>概率论和无穷级数到大后期又跟了一遍方浩。</p><p>记得不要跟考研竞赛凯哥，具体原因自己去找。</p><hr><p>邂逅遗憾知乎的经验贴害惨了我，让我觉得我也能上，建议看他经验贴之前撒泡尿照照自己。</p><p>rw现在每年炸成这样，有很大一部分原因就是他知乎的经验帖。</p><p>但是他经验帖写的确实好，他推荐的方浩概率论确实不错，</p><p>他自己办的课挺贵的，小班八百多大班四千多，我没听过不做评价。</p><hr><p>就是方浩的那个书和他的课程不配套真的很烦，我学概率论的时候一大部分时间都在抄他的课上例题，因为题确实有用，</p><p>尤其是张宇的课和他的书配套的极其丝滑，再听方浩的课感觉跟吔了史一样。</p><p>建议别买方浩的书，直接买风中易小生做的方浩做题本自己打印，我也是后来才发现风中易小生的做题本都给整理好了。</p><hr><p>我虽然考得烂，但张宇老师确实好，教材做得很全，</p><p>上课生动形象，体谅学生，到现在我还记得他讲的狮子王的故事，不过当时听的时候我倍速过去了。</p><p>据说今年数学这样之后各大经验贴都主推张宇老师了，因为张宇老师的全程班基础性好的同时扩展度最高。</p><hr><p>只能说从此往后，如果卷考研的人继续增多，数学的难度和扩展性也会越来越大，越来越起到选拔人才的作用，</p><p>今年就是最好的例子，狠狠给了我当头一棒，</p><p>没有两把刷子的人好好掂量掂量自己。</p><hr><p>武老师我是真听不进去，语调太平，感觉像是大学里读ppt的老师，但是有很多跟武老师的人分数也很高，所以这两大派系的选择主要还是看自己。</p><hr><p>周围基础不好的有跟周洋鑫的，</p><p>我本来不太了解这个人，就是最后的时候做了他出的三套卷，</p><p>猛然觉得，嗬这题出得好像真题，好有水平，然后一看发现很多都是真题改编的。</p><p>感觉应该也是个好老师。</p><hr><p>我现在回忆，基础阶段和强化阶段在我脑海里是空白的，</p><p>我觉得这有可能就是我数学考成这个样子的原因。</p><p>像是盘古还未开天辟地时的混沌。</p><hr><h2 id="4-408"><a href="#4-408" class="headerlink" title="4.408"></a>4.408</h2><p><img src="/images/image-20240302230426611.png" alt="image-20240302230426611"></p><hr><p>最后来个总结吧，再低也是我辛辛苦苦考出来的分</p><p>这个系统我这辈子估计也不会再进了。</p><p>（未写完，图之后贴）</p><p><img src="/images/image-20240302230509125.png" alt="image-20240302230509125"></p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重新搞了博客</title>
    <link href="/2024/02/29/%E9%87%8D%E6%96%B0%E6%90%9E%E4%BA%86%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/02/29/%E9%87%8D%E6%96%B0%E6%90%9E%E4%BA%86%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>重新搞了博客，</p><p>21年刚开始整博客的时候，把博客放在了我自己的云服务器里，觉得既然买了就不用白不用，顺便练练运维啥的。</p><p>后来那个服务器承担了我很多的学习任务和尝试，所以经常遇到依赖地狱，</p><p>一旦十几个小时卡在某个依赖上毫无进展，我就直接气得重装整个服务器，</p><p>又懒得在外边套docker，所以连带着博客也得重装，我的评价是活该，</p><p>重装了几次之后就气坏了，懒得搞了，荒废了两年。</p><hr><p>最近重新整是因为，我简历上写了我的个人网站，<del>为了凑数</del>，最近震惊地发现还真有导师认真看了，所以不得不修缮一下。</p><p>最终决定将博客作为一个lifelong的项目维持，为了省钱省力气挂在了github上，再重定向到我原来的域名，一举两得。</p><hr><p>以前是把公众号的内容都搬过来，但是现在没那精力了，</p><p>因为微信公众号不支持md格式，导致我每次写完md之后还要贴到公众号上去精修一下，后来就演变成md只写草稿，再粘贴到公众号的编辑框写详细。</p><p>所以要么写个脚本，发哪个平台就全自动化移植到另一个平台，要么就两个平台单独更新吧，这边写点儿那边不让写的。</p><p>有空的时候我还是想完全自己写博客的前后端，现在用hexo主要是没时间，至于什么时候有时间，我觉得得等到上研究生之后，或者工作之后，或者退休之后了。</p><p>真是人生到处知何似，应似飞鸿踏雪泥啊。</p><hr><p>以及欢迎各位佬联系我添加友链。</p>]]></content>
    
    
    <categories>
      
      <category>杂想</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
